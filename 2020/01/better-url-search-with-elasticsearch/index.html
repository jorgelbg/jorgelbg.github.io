<!doctype html><html lang=en-us><head><link rel=preload href=//jorgelbg.me/css/style.css as=style><link rel=stylesheet href=//jorgelbg.me/css/style.css media=print onload="this.media='all'"><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Jorge Luis Betancourt"><meta name=description content="Computo Ergo Sum"><meta name=generator content="Hugo 0.60.1"><title>Better URL search with Elasticsearch</title><link rel="shortcut icon" href=//jorgelbg.me/images/favicon.ico><link rel=dns-prefetch href=//www.google-analytics.com/><link href=//jorgelbg.me/index.xml rel=alternate type=application/rss+xml title="Jorge Luis Betancourt"><meta property="og:title" content="Better URL search with Elasticsearch"><meta property="og:description" content="Improved URL search in Elasticsearch using custom analyzers."><meta property="og:type" content="article"><meta property="og:url" content="//jorgelbg.me/2020/01/better-url-search-with-elasticsearch/"><meta property="article:published_time" content="2020-01-01T11:46:14-05:00"><meta property="article:modified_time" content="2020-02-11T15:17:59+01:00"><meta itemprop=name content="Better URL search with Elasticsearch"><meta itemprop=description content="Improved URL search in Elasticsearch using custom analyzers."><meta itemprop=datePublished content="2020-01-01T11:46:14-05:00"><meta itemprop=dateModified content="2020-02-11T15:17:59+01:00"><meta itemprop=wordCount content="1029"><meta itemprop=keywords content="elasticsearch,search,url,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Better URL search with Elasticsearch"><meta name=twitter:description content="Improved URL search in Elasticsearch using custom analyzers."><meta name=twitter:site content="@https://twitter.com/jorgelbg"></head><body><section id=wrapper><nav class=main-nav><a href=//jorgelbg.me></a></nav><article class=post><header><h1><a href=//jorgelbg.me/2020/01/better-url-search-with-elasticsearch/><svg width="30" xmlns="http://www.w3.org/2000/svg" version="1" viewBox="0 0 483 483"><path d="M255 209c-5 6-5 14 0 19 22 22 22 58 0 80L140 423a56 56 0 01-79 0l-18-17a56 56 0 010-80l115-115c6-5 6-14 1-19s-14-5-20 0L24 307a83 83 0 000 118l18 17a83 83 0 00117 0l115-115c33-32 33-85 0-118-5-5-13-5-19 0z"/><path d="M459 58l-18-17a83 83 0 00-117 0L209 156a83 83 0 000 118c5 5 13 5 19 0s5-14 0-20a56 56 0 010-79L343 60c22-22 57-22 79 0l17 17c22 22 22 58 0 80L324 272c-5 5-5 13 0 19 3 2 7 4 10 4s7-1 9-4l115-115a83 83 0 001-118z"/></svg>Better URL search with Elasticsearch</a></h1><h2 class=headline><span>January 1, 2020</span>
<span class=tag><svg fill="#718096" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16"><path class="heroicon-ui" d="M2.59 13.41A1.98 1.98.0 012 12V7a5 5 0 015-5h4.99c.53.0 1.04.2 1.42.59l8 8a2 2 0 010 2.82l-8 8a2 2 0 01-2.82.0l-8-8zM20 12l-8-8H7A3 3 0 004 7v5l8 8 8-8zM7 8a1 1 0 110-2 1 1 0 010 2z"/></svg><a style=margin-left:10px href=//jorgelbg.me/tags/elasticsearch>elasticsearch</a></span>
<span class=tag><svg fill="#718096" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16"><path class="heroicon-ui" d="M2.59 13.41A1.98 1.98.0 012 12V7a5 5 0 015-5h4.99c.53.0 1.04.2 1.42.59l8 8a2 2 0 010 2.82l-8 8a2 2 0 01-2.82.0l-8-8zM20 12l-8-8H7A3 3 0 004 7v5l8 8 8-8zM7 8a1 1 0 110-2 1 1 0 010 2z"/></svg><a style=margin-left:10px href=//jorgelbg.me/tags/search>search</a></span>
<span class=tag><svg fill="#718096" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16"><path class="heroicon-ui" d="M2.59 13.41A1.98 1.98.0 012 12V7a5 5 0 015-5h4.99c.53.0 1.04.2 1.42.59l8 8a2 2 0 010 2.82l-8 8a2 2 0 01-2.82.0l-8-8zM20 12l-8-8H7A3 3 0 004 7v5l8 8 8-8zM7 8a1 1 0 110-2 1 1 0 010 2z"/></svg><a style=margin-left:10px href=//jorgelbg.me/tags/url>url</a></span></h2><p class=last-edited><a href=https://github.com/jorgelbg/jorgelbg.github.io/commit/80d4cbffd9c4f47fd65efe95ee35703f0de7fff6 title="Add crossposting note&link to the trivago tech blog">Last edited on 11 February 2020</a></p></header><section id=post-body><blockquote><p>ðŸš€ This article has been crossposted in the [trivago tech blog]
(<a href=https://tech.trivago.com/2020/02/11/better-url-search-with-elasticsearch/)>https://tech.trivago.com/2020/02/11/better-url-search-with-elasticsearch/)</a>.</p></blockquote><p>At trivago, we generate a huge amount of logs and we have our <a href=https://tech.trivago.com/2016/01/19/logstash_protobuf_codec/>own custom setup for shipping
logs</a> using mostly <a href=https://developers.google.com/protocol-buffers>Protocol
Buffers</a>. Eventually we end up with some fields in ES
that contain partial (or full) URLs. For instance in our specific case we store the <a href=https://en.wikipedia.org/wiki/URL#Syntax>query
component</a> of the URL in a field called <code>query</code> and the
<a href=https://en.wikipedia.org/wiki/URL#Syntax>path component</a> in a field named <code>url_path</code>. Sample values
for these fields could be:</p><div class=highlight><pre class=chroma><code class=language-sh data-lang=sh><span class=nv>url_path</span> <span class=o>=</span> <span class=s2>&#34;/webservice/search/hotels/43326/rates&#34;</span>
<span class=nv>query</span> <span class=o>=</span> <span class=s2>&#34;from_date=2020-06-01T00:00:00%2B02:00&amp;to_date=2020-06-10T00:00:00%2B02:00&amp;currency=EUR&amp;room_type=9&amp;room_0=2a&amp;fixed_status=1&#34;</span>
</code></pre></div><p>We use the ELK stack as the core of our logging pipeline. Since Elasticsearch's primary use-case was that of a search engine, it comes equipped with a diverse assortment of tools to process data. Searching on
these URL-like texts is not the same as trying to search in a summary of a book. When a field is
defined as <code>text</code> in ES, it will apply by default the <a href=https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-standard-analyzer.html>Standard
Analyzer</a>.</p><p>The Standard Analyzer uses the <a href=https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-standard-tokenizer.html>Standard
Tokenizer</a>,
which provides grammar-based tokenization. Put simply: if the value of the field would be an English
sentence written using ASCII characters, the tokenizer will split the text based on punctuation signs,
spaces and some special characters (like <code>/</code> for instance).</p><p>This tokenizer works quite well for our <code>url_path</code> field:</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>POST _analyze
<span class=o>{</span>
 <span class=s2>&#34;tokenizer&#34;</span>: <span class=s2>&#34;standard&#34;</span>,
 <span class=s2>&#34;text&#34;</span>: <span class=s2>&#34;/webservice/search/hotels/43326/rates&#34;</span>
<span class=o>}</span>
</code></pre></div><p>Producing the following list of tokens:</p><div class=highlight><pre class=chroma><code class=language-json data-lang=json><span class=p>[</span> <span class=s2>&#34;webservice&#34;</span><span class=p>,</span> <span class=s2>&#34;search&#34;</span><span class=p>,</span> <span class=s2>&#34;hotels&#34;</span><span class=p>,</span> <span class=s2>&#34;43326&#34;</span><span class=p>,</span> <span class=s2>&#34;rates&#34;</span> <span class=p>]</span>
</code></pre></div><p>If we test the value of the <code>query</code> field against this tokenizer, we can see that it produces a lot
of useless tokens:</p><div class=highlight><pre class=chroma><code class=language-json data-lang=json><span class=p>[</span> <span class=s2>&#34;from_date&#34;</span><span class=p>,</span> <span class=s2>&#34;2020&#34;</span><span class=p>,</span> <span class=s2>&#34;06&#34;</span><span class=p>,</span> <span class=s2>&#34;01T00&#34;</span><span class=p>,</span> <span class=s2>&#34;00&#34;</span><span class=p>,</span> <span class=s2>&#34;00&#34;</span><span class=p>,</span> <span class=s2>&#34;2B02&#34;</span><span class=p>,</span> <span class=s2>&#34;00&#34;</span><span class=p>,</span> <span class=s2>&#34;to_date&#34;</span><span class=p>,</span> <span class=s2>&#34;2020&#34;</span><span class=p>,</span> <span class=s2>&#34;06&#34;</span><span class=p>,</span> <span class=s2>&#34;10T00&#34;</span><span class=p>,</span> <span class=s2>&#34;00&#34;</span><span class=p>,</span> <span class=s2>&#34;00&#34;</span><span class=p>,</span> <span class=s2>&#34;2B02&#34;</span><span class=p>,</span> <span class=s2>&#34;00&#34;</span><span class=p>,</span> <span class=s2>&#34;currency&#34;</span><span class=p>,</span> <span class=s2>&#34;EUR&#34;</span><span class=p>,</span> <span class=s2>&#34;room_type&#34;</span><span class=p>,</span> <span class=s2>&#34;9&#34;</span><span class=p>,</span> <span class=s2>&#34;room_0&#34;</span><span class=p>,</span> <span class=s2>&#34;2a&#34;</span><span class=p>,</span> <span class=s2>&#34;fixed_status&#34;</span><span class=p>,</span> <span class=s2>&#34;1&#34;</span> <span class=p>]</span>
</code></pre></div><p>Although it detected the <code>from_date</code> field, it fails to tokenize the value of the query
parameters as a single token, which makes searching very difficult.</p><p>It is more likely for a user to want to find documents where <code>currency</code> is set to <code>EUR</code> or
<code>room_type</code> equal to <code>9</code>. Generalizing this means that the users are interested in matching on the
key/value pairs present in the query string.</p><p>Let's go over a couple of ways we could approach this.</p><p>We could pre-process the data and make our Logstash pipeline split the data into multiple
fields (using the <a href=https://www.elastic.co/guide/en/logstash/current/plugins-filters-kv.html><code>kv</code> filter</a>
for instance). Creating a new field for each attribute in the query string could lead to a
cardinality explosion in our indexes, even more, considering that any user could create
random key/value pairs.</p><p>We could work around the cardinality issue by flattening the structure and having a couple of nested
fields (<code>name</code> and <code>value</code>):</p><ul><li><code>query.name</code> the field that could hold the attribute name</li><li><code>query.value</code> that would hold the value</li></ul><p>This approach would introduce yet another problem. The <code>query</code> field would have to be an array of objects
and as such, it would lead to queries matching in unexpected ways. Let me explain:</p><p>If we have the following values for our <code>query</code> field (as an array of objects) in a couple of documents:</p><div class=highlight><pre class=chroma><code class=language-json data-lang=json><span class=s2>&#34;query&#34;</span><span class=err>:</span> <span class=p>[</span>
    <span class=p>{</span> <span class=nt>&#34;name&#34;</span><span class=p>:</span><span class=s2>&#34;currency&#34;</span><span class=p>,</span> <span class=nt>&#34;value&#34;</span><span class=p>:</span><span class=s2>&#34;EUR&#34;</span> <span class=p>}</span><span class=p>,</span>
    <span class=p>{</span> <span class=nt>&#34;name&#34;</span><span class=p>:</span><span class=s2>&#34;room_type&#34;</span><span class=p>,</span> <span class=nt>&#34;value&#34;</span><span class=p>:</span><span class=s2>&#34;9&#34;</span> <span class=p>}</span><span class=p>,</span>
<span class=p>]</span>
</code></pre></div><p>A query such as this one:</p><div class=highlight><pre class=chroma><code class=language-js data-lang=js><span class=nx>query</span><span class=p>.</span><span class=nx>name</span><span class=o>:</span><span class=s2>&#34;currency&#34;</span> <span class=nx>AND</span> <span class=nx>query</span><span class=p>.</span><span class=nx>value</span><span class=o>:</span><span class=s2>&#34;9&#34;</span>
</code></pre></div><p>would match our sample document although it would be matching for the <em>&ldquo;wrong reasons&rdquo;</em>. In our
example, <code>currency</code> doesn't have a value of <code>9</code>, but since both boolean conditions are evaluated as
<code>true</code>, the given document would produce a match. It is more likely that the user firing this query
wants to match on <code>currency</code> having the value <code>9</code> which <em>should not</em> produce any matches in our sample
data.</p><h2 id=our-solution>Our solution</h2><p>Since our end goal is to match by attribute name/value pair, if we could make these pairs a <strong>single
token</strong>, we would accomplish our goal with the benefit of having a single field and not strange
matches. With this approach, each key/value pair of the query string would be a single
token in the form of <code>name1=value1</code> and <code>name2=value2</code>. This means that then we could write a query
like:</p><div class=highlight><pre class=chroma><code class=language-js data-lang=js><span class=nx>query</span><span class=o>:</span><span class=s2>&#34;currency=EUR&#34;</span>
</code></pre></div><p>This changes how we can query the data, but it guarantees that it would not produce false matches.
Since we don't generate new fields dynamically, there is also no risk of having cardinality issues.</p><p>The tokenization can be implemented in different places in the pipeline. Using the <a href=https://www.elastic.co/guide/en/logstash/current/plugins-filters-split.html>split
filter</a> or the
previously mentioned <a href=https://www.elastic.co/guide/en/logstash/current/plugins-filters-kv.html>kv
filter</a>. We decided to
use a <a href=https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-pattern-analyzer.html>custom pattern analyzer</a> on the Elasticsearch side.</p><p>Our <code>pattern_analyzer</code> uses a custom tokenizer defined as:</p><div class=highlight><pre class=chroma><code class=language-json data-lang=json><span class=s2>&#34;url_pattern&#34;</span><span class=err>:</span> <span class=p>{</span>
    <span class=nt>&#34;pattern&#34;</span><span class=p>:</span> <span class=s2>&#34;&amp;&#34;</span><span class=p>,</span>
    <span class=nt>&#34;type&#34;</span><span class=p>:</span> <span class=s2>&#34;pattern&#34;</span>
<span class=p>}</span>
</code></pre></div><p>We also use a custom <code>char_filter</code> to handle the decoding of some special characters into their ASCII
equivalent, which makes the queries more user friendly:</p><div class=highlight><pre class=chroma><code class=language-json data-lang=json><span class=s2>&#34;char_filter&#34;</span><span class=err>:</span> <span class=p>{</span>
    <span class=nt>&#34;url_escape_filter_mapping&#34;</span><span class=p>:</span> <span class=p>{</span>
        <span class=nt>&#34;type&#34;</span><span class=p>:</span> <span class=s2>&#34;mapping&#34;</span><span class=p>,</span>
        <span class=nt>&#34;mappings&#34;</span><span class=p>:</span> <span class=p>[</span>
            <span class=s2>&#34;%20 =&gt; +&#34;</span><span class=p>,</span>
            <span class=s2>&#34;%2B =&gt; +&#34;</span><span class=p>,</span>
            <span class=s2>&#34;%2C =&gt; ,&#34;</span><span class=p>,</span>
            <span class=s2>&#34;%3A =&gt; :&#34;</span><span class=p>,</span>
            <span class=s2>&#34;%5E =&gt; ^&#34;</span><span class=p>,</span>
            <span class=s2>&#34;%7C =&gt; |&#34;</span><span class=p>,</span>
            <span class=s2>&#34;%3D =&gt; =&#34;</span><span class=p>,</span>
            <span class=s2>&#34;%5B =&gt; [&#34;</span><span class=p>,</span>
            <span class=s2>&#34;%5D =&gt; ]&#34;</span>
        <span class=p>]</span>
    <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>Finally, we define a custom analyzer called <code>pattern_analyzer</code>:</p><div class=highlight><pre class=chroma><code class=language-json data-lang=json><span class=s2>&#34;pattern_analyzer&#34;</span><span class=err>:</span> <span class=p>{</span>
    <span class=nt>&#34;filter&#34;</span><span class=p>:</span> <span class=p>[</span>
        <span class=s2>&#34;lowercase&#34;</span><span class=p>,</span>
        <span class=s2>&#34;asciifolding&#34;</span><span class=p>,</span>
        <span class=s2>&#34;stop&#34;</span><span class=p>,</span>
        <span class=s2>&#34;unique&#34;</span>
    <span class=p>]</span><span class=p>,</span>
    <span class=nt>&#34;char_filter&#34;</span><span class=p>:</span> <span class=p>[</span>
        <span class=s2>&#34;html_strip&#34;</span><span class=p>,</span>
        <span class=s2>&#34;url_escape_filter_mapping&#34;</span>
    <span class=p>]</span><span class=p>,</span>
    <span class=nt>&#34;type&#34;</span><span class=p>:</span> <span class=s2>&#34;custom&#34;</span><span class=p>,</span>
    <span class=nt>&#34;tokenizer&#34;</span><span class=p>:</span> <span class=s2>&#34;url_pattern&#34;</span>
<span class=p>}</span>
</code></pre></div><p>This analyzer is used in our mapping templates:</p><div class=highlight><pre class=chroma><code class=language-json data-lang=json><span class=s2>&#34;query&#34;</span><span class=err>:</span> <span class=p>{</span>
    <span class=nt>&#34;norms&#34;</span><span class=p>:</span> <span class=kc>false</span><span class=p>,</span>
    <span class=nt>&#34;analyzer&#34;</span><span class=p>:</span> <span class=s2>&#34;pattern_analyzer&#34;</span><span class=p>,</span>
    <span class=nt>&#34;type&#34;</span><span class=p>:</span> <span class=s2>&#34;text&#34;</span>
<span class=p>}</span><span class=err>,</span>
</code></pre></div><p>If we test the initial value of our <code>query</code> field against the field using the custom analyzer:</p><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>POST accesslogs/_analyze
<span class=o>{</span>
    <span class=s2>&#34;field&#34;</span>: <span class=s2>&#34;query&#34;</span>,
    <span class=s2>&#34;text&#34;</span>: <span class=s2>&#34;from_date=2020-06-01T00:00:00%2B02:00&amp;to_date=2020-06-10T00:00:00%2B02:00&amp;currency=EUR&amp;room_type=9&amp;room_0=2a&amp;fixed_status=1&#34;</span>
<span class=o>}</span>
</code></pre></div><p>We get a more useful list of tokens:</p><div class=highlight><pre class=chroma><code class=language-json data-lang=json><span class=p>[</span> <span class=s2>&#34;from_date=2020-06-01t00:00:00+02:00&#34;</span><span class=p>,</span> <span class=s2>&#34;to_date=2020-06-10t00:00:00+02:00&#34;</span><span class=p>,</span> <span class=s2>&#34;currency=eur&#34;</span><span class=p>,</span> <span class=s2>&#34;room_type=9&#34;</span><span class=p>,</span> <span class=s2>&#34;room_0=2a&#34;</span><span class=p>,</span> <span class=s2>&#34;fixed_status=1&#34;</span> <span class=p>]</span>
</code></pre></div><p>Using this list of tokens, it is easier to find those specific requests that we're looking for. It is
even more intuitive what is going on if we need to share the query with a colleague.</p><div class=info><svg width="50" version="1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M256 0A246 246 0 0075 413l-13 88a10 10 0 0014 10l79-41A246 246 0 10256 0zm0 472c-34 0-67-7-97-22-3-1-6-1-9 1l-66 34 11-74c1-3 0-6-2-8a227 227 0 11163 70z"/><path d="M256 71a51 51 0 100 102 51 51 0 000-102zm0 83a32 32 0 110-64 32 32 0 010 64zm57 204h-11V199c0-5-5-10-10-10h-93c-5 0-9 5-9 10v32c0 6 4 10 9 10h11v117h-11c-5 0-9 4-9 9v33c0 5 4 9 9 9h114c5 0 9-4 9-9v-33c0-5-4-9-9-9zm-10 32h-94v-13h11c5 0 10-4 10-10V231c0-5-5-9-10-9h-11v-13h73v158c0 6 5 10 10 10h11v13z"/></svg><p>We could've decided to write our own tokenizer to deal with URLs. It would have provided us with full
control over the Token Stream (i.e tokens) produced by Elasticsearch. Still, dealing with custom
analyzers involves writing and maintaining custom plugins, which would have been definitively more
difficult to support in the long run. Instead, we chose to leverage the already quite flexible
toolbox provided by Elasticsearch.</p></div><h2 id=thanks>Thanks</h2><p>I want to thank my colleague <a href=https://github.com/unidario>ðŸ¦„ Dario Segger</a> (currently ex-teammate)
that did the implementation described in this post. We've been using this approach for some time now.</p></section></article><footer id=post-meta class=clearfix><svg class="avatar" width="50" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="#cbd5e0" d="M20.3 12.04l1.01 3a1 1 0 01-1.26 1.27l-3.01-1a7 7 0 113.27-3.27zM11 10a1 1 0 100-2 1 1 0 000 2zm3 0a1 1 0 100-2 1 1 0 000 2zm3 0a1 1 0 100-2 1 1 0 000 2z"/><path fill="#4a5568" d="M15.88 17.8a7 7 0 01-8.92 2.5l-3 1.01a1 1 0 01-1.27-1.26l1-3.01A6.97 6.97.0 015 9.1a9 9 0 0010.88 8.7z"/></svg><a href=https://twitter.com/jorgelbg><div><span class=dark>Want to leave a comment?</span>
<span>Drop me a message on Twitter @jorgelbg</span></div></a><section id=sharing><a class=twitter target=_blank href="https://twitter.com/intent/tweet?text=%2f%2fjorgelbg.me%2f2020%2f01%2fbetter-url-search-with-elasticsearch%2f - Better%20URL%20search%20with%20Elasticsearch by @jorgelbg"><span class=icon-twitter>tweet</span></a></section></footer><ul id=post-list class="archive readmore"><h3>Read more</h3><li><a href=//jorgelbg.me/2019/05/how-to-rename-index-patterns-in-kibana/><span>How to rename index patterns in Kibana</span><aside class=dates>May 21 2019</aside></a></li><li><a href=//jorgelbg.me/2019/03/useful-alerts-with-elastic-watcher-machine-learning/><span>Useful alerts with Elastic Watcher & Machine Learning</span><aside class=dates>Mar 15 2019</aside></a></li><li><a href=//jorgelbg.me/2019/02/display-the-applications-version-in-your-grafana-dashboards/><span>Display the application's version in your Grafana dashboards</span><aside class=dates>Feb 17 2019</aside></a></li></ul><footer id=footer><p class=small>Â© Copyright 2020 Jorge Luis Betancourt</p><p class="small cc">Icons made by
<a href=https://www.freepik.com/ title=Freepik>Freepik</a> from
<a href=https://www.flaticon.com/ title=Flaticon>www.flaticon.com</a> is
licensed by
<a href=https://creativecommons.org/licenses/by/3.0/ title="Creative Commons BY 3.0" target=_blank>CC 3.0 BY</a></p></footer></section><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-115201846-1','auto');ga('send','pageview');}</script></body></html>