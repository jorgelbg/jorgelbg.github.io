<!doctype html><html lang=en-us><head><link rel=preload href=//jorgelbg.me/css/style.css as=style><link rel=stylesheet href=//jorgelbg.me/css/style.css media=print onload="this.media='all'"><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Jorge Luis Betancourt"><meta name=description content="Computo Ergo Sum"><meta name=generator content="Hugo 0.60.1"><title>Optimize Grafana dashboards with Elasticsearch index aliases</title><link rel="shortcut icon" href=//jorgelbg.me/images/favicon.ico><link rel=dns-prefetch href=//www.google-analytics.com/><link href=//jorgelbg.me/index.xml rel=alternate type=application/rss+xml title="Jorge Luis Betancourt"><meta property="og:title" content="Optimize Grafana dashboards with Elasticsearch index aliases"><meta property="og:description" content="Elasticsearch aliases can apply filters automatically to your queries. Let's use it to speed up some Grafana dashboards.&#34;"><meta property="og:type" content="article"><meta property="og:url" content="//jorgelbg.me/2018/12/optimize-grafana-dashboards-with-elasticsearch-index-aliases/"><meta property="article:published_time" content="2018-12-20T00:00:00+01:00"><meta property="article:modified_time" content="2019-12-13T13:22:34+01:00"><meta itemprop=name content="Optimize Grafana dashboards with Elasticsearch index aliases"><meta itemprop=description content="Elasticsearch aliases can apply filters automatically to your queries. Let's use it to speed up some Grafana dashboards.&#34;"><meta itemprop=datePublished content="2018-12-20T00:00:00+01:00"><meta itemprop=dateModified content="2019-12-13T13:22:34+01:00"><meta itemprop=wordCount content="1597"><meta itemprop=keywords content="grafana,elasticsearch,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Optimize Grafana dashboards with Elasticsearch index aliases"><meta name=twitter:description content="Elasticsearch aliases can apply filters automatically to your queries. Let's use it to speed up some Grafana dashboards.&#34;"><meta name=twitter:site content="@https://twitter.com/jorgelbg"></head><body><section id=wrapper><nav class=main-nav><a href=//jorgelbg.me></a></nav><article class=post><header><h1><a href=/2018/12/optimize-grafana-dashboards-with-elasticsearch-index-aliases/><svg width="30" xmlns="http://www.w3.org/2000/svg" version="1" viewBox="0 0 483 483"><path d="M255 209c-5 6-5 14 0 19 22 22 22 58 0 80L140 423a56 56 0 01-79 0l-18-17a56 56 0 010-80l115-115c6-5 6-14 1-19s-14-5-20 0L24 307a83 83 0 000 118l18 17a83 83 0 00117 0l115-115c33-32 33-85 0-118-5-5-13-5-19 0z"/><path d="M459 58l-18-17a83 83 0 00-117 0L209 156a83 83 0 000 118c5 5 13 5 19 0s5-14 0-20a56 56 0 010-79L343 60c22-22 57-22 79 0l17 17c22 22 22 58 0 80L324 272c-5 5-5 13 0 19 3 2 7 4 10 4s7-1 9-4l115-115a83 83 0 001-118z"/></svg>Optimize Grafana dashboards with Elasticsearch index aliases</a></h1><h2 class=headline><span>December 20, 2018</span>
<span class=tag><svg fill="#718096" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16"><path class="heroicon-ui" d="M2.59 13.41A1.98 1.98.0 012 12V7a5 5 0 015-5h4.99c.53.0 1.04.2 1.42.59l8 8a2 2 0 010 2.82l-8 8a2 2 0 01-2.82.0l-8-8zM20 12l-8-8H7A3 3 0 004 7v5l8 8 8-8zM7 8a1 1 0 110-2 1 1 0 010 2z"/></svg><a style=margin-left:10px href=//jorgelbg.me/tags/grafana>grafana</a></span>
<span class=tag><svg fill="#718096" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16"><path class="heroicon-ui" d="M2.59 13.41A1.98 1.98.0 012 12V7a5 5 0 015-5h4.99c.53.0 1.04.2 1.42.59l8 8a2 2 0 010 2.82l-8 8a2 2 0 01-2.82.0l-8-8zM20 12l-8-8H7A3 3 0 004 7v5l8 8 8-8zM7 8a1 1 0 110-2 1 1 0 010 2z"/></svg><a style=margin-left:10px href=//jorgelbg.me/tags/elasticsearch>elasticsearch</a></span></h2><p class=last-edited><a href=https://github.com/jorgelbg/jorgelbg.github.io/commit/2d6f2c922b16684f792c3bb948117abcf9d94d8b title="Fix styling for the kbd elements">Last edited on 13 December 2019</a></p></header><section id=post-body><p>Grafana is a very popular opensource dashboarding solution. Provides support
for a long list of storage solutions, including Elasticsearch.
Unfortunately, the ES support is not at the same level as the one you get for
InfluxDB, for instance. Still, Grafana allows combining in the same
dashboard different data sources. It is possible to have a panel fetching data
from ES and a different panel fetching data from InfluxDB.</p><h2 id=grafana--elasticsearch>Grafana ❤️ Elasticsearch</h2><p>Grafana provides stellar support for <a href=https://www.influxdata.com/>InfluxDB</a>
& <a href=http://docs.grafana.org/features/datasources/prometheus/>Prometheus</a>,
among others. This means that you get, query autocompletion for fields, values,
etc. When you select ES as a data source for a panel, the features are a bit less
polished. You are greet by a &ldquo;Lucene query&rdquo; input and some more options.
Depending on the metric (aggregation), Grafana also provides some help
for field name selection when using ES as a data source.</p><p>Up to this point, everything is ok, Elasticsearch is not a first citizen in the
Grafana ecosystem, but it's supported and maintained). The issue
that we had a few days ago (and that inspired the content of this post) was
instead related to the query that Grafana sends to ES.</p><p>Let's say that we want to calculate the average of a <code>memcache</code> field in a
specific index stored in ES. Only for a subset of our hosts (those that start
with <code>www</code>). Using a Lucene syntax we can &ldquo;filter&rdquo; to only a subset of the
hosts with the following query:</p><pre><code>header.senderId:www*
</code></pre><p>We could put the same query in a Grafana panel, and we end up with
something like this:</p><p><img src=/images/elasticsearch-indices-grafana/grafana-example-query.png alt="Grafana Example Elasticsearch query" title="Example of a Grafana Elasticsearch query in a panel"></p><p>If we check the <a href=http://docs.grafana.org/guides/whats-new-in-v4-5/#query-inspector>Query Inspector</a>
we can see the query that Grafana sends to ES (actually to the proxy, but
this detail is not important). The relevant section is the
<code>request.data</code> attribute, that looks like:</p><div class=highlight><pre class=chroma><code class=language-json data-lang=json><span class=p>{</span>
  <span class=nt>&#34;size&#34;</span><span class=p>:</span> <span class=mi>0</span><span class=p>,</span>
  <span class=nt>&#34;query&#34;</span><span class=p>:</span> <span class=p>{</span>
    <span class=nt>&#34;bool&#34;</span><span class=p>:</span> <span class=p>{</span>
      <span class=nt>&#34;filter&#34;</span><span class=p>:</span> <span class=p>[</span>
        <span class=p>{</span>
          <span class=nt>&#34;range&#34;</span><span class=p>:</span> <span class=p>{</span>
            <span class=nt>&#34;@timestamp&#34;</span><span class=p>:</span> <span class=p>{</span>
              <span class=nt>&#34;gte&#34;</span><span class=p>:</span> <span class=s2>&#34;1544518226265&#34;</span><span class=p>,</span>
              <span class=nt>&#34;lte&#34;</span><span class=p>:</span> <span class=s2>&#34;1544539826265&#34;</span><span class=p>,</span>
              <span class=nt>&#34;format&#34;</span><span class=p>:</span> <span class=s2>&#34;epoch_millis&#34;</span>
            <span class=p>}</span>
          <span class=p>}</span>
        <span class=p>}</span><span class=p>,</span>
        <span class=p>{</span>
          <span class=nt>&#34;query_string&#34;</span><span class=p>:</span> <span class=p>{</span>
            <span class=nt>&#34;analyze_wildcard&#34;</span><span class=p>:</span> <span class=kc>true</span><span class=p>,</span>
            <span class=nt>&#34;query&#34;</span><span class=p>:</span> <span class=s2>&#34;header.senderId:www*&#34;</span>
          <span class=p>}</span>
        <span class=p>}</span>
      <span class=p>]</span>
    <span class=p>}</span>
  <span class=p>}</span><span class=p>,</span>
  <span class=nt>&#34;aggs&#34;</span><span class=p>:</span> <span class=p>{</span>
      <span class=nt>&#34;...&#34;</span><span class=p>:</span> <span class=s2>&#34;...&#34;</span><span class=p>,</span>
  <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>We can see that Grafana is applying a
<a href=https://www.elastic.co/guide/en/elasticsearch/reference/6.5/query-dsl-filtered-query.html>Filtered Query</a>.
One small detail is that whatever we put in our &ldquo;Lucene query&rdquo; input field will
be placed in the <code>query_string</code> section, as an extra <em>filter</em>. This is
great for 90% of the queries, the problem is that if you're querying a large
enough dataset (let's say you want to aggregate over 19M documents), and you're
applying a lot of filters (like searching for specific hosts). This can have an
impact on the performance of your query.</p><blockquote><p>Not everything is bad if you're using a time-based index pattern, and your
Elasticsearch data source in Grafana is properly configured, Grafana will know
to which indexes send the query depending on the time range, pretty cool!.</p></blockquote><h2 id=the-problem>The problem</h2><p>So far, we've talked only about how Grafana works. One of our users reported
that from time to time a specific Grafana dashboard would be slow while
fetching data from ES. We saw this issue in our internal monitoring as well:</p><p><img src=/images/elasticsearch-indices-grafana/periodic-query-time-spike.png alt="Periodic spikes in Elasticsearch response times" title="Periodic spikes in Elasticsearch response times shown in the internal monitoring"></p><p>This graph shows that approximately every hour we had a spike in the ES query
time, spiking to ~7s. After some detective work, one coworker found the
culprit dashboard. Considering that the query was executing periodically, it was
a good bet that the query was coming from some sort of automated source (like a
dashboard put in a rotation).</p><p>After identifying the problematic query we realized that the query was hitting
a lot of unnecessary shards (last 30 days). We fix it by
configuring the data source to use the daily pattern. This helped with reducing
the number of shards that the query hit. Still, it didn't impact
<em>significantly</em> the response time of the query. This is a testimony
of how efficient ES/Lucene is.</p><h2 id=time-to-profile>Time to profile</h2><p>At this point, there is not a lot of things that we can do, except profiling the
query. Kibana comes bundled with a
<a href=https://www.elastic.co/guide/en/kibana/current/xpack-profiler.html>Search Profiler</a>
with the basic version of X-pack. Putting the query in the profiler and hitting
the
<kbd>Profile</kbd>
button already provided a lot of insight:</p><p><img src=/images/elasticsearch-indices-grafana/original-query-profile.png alt="Profile of the original Grafana query" title="Profiling of the original query taking a long time"></p><p>To reduce the noise introduced. we decided to query one specific index. For 1
day of data the query that Grafana was sending to ES was taking ~40s <strong>(inside
the profiler)</strong>. Of course, a significant part of this time comes from the
profiling itself. We knew that on production for the last 2 days this time
was ~7s. So we decided to use the 40s as a base reference.</p><p>The real query looked very similar to:</p><div class=highlight><pre class=chroma><code class=language-json data-lang=json><span class=p>{</span>
  <span class=nt>&#34;size&#34;</span><span class=p>:</span> <span class=mi>0</span><span class=p>,</span>
  <span class=nt>&#34;query&#34;</span><span class=p>:</span> <span class=p>{</span>
    <span class=nt>&#34;bool&#34;</span><span class=p>:</span> <span class=p>{</span>
      <span class=nt>&#34;filter&#34;</span><span class=p>:</span> <span class=p>[</span>
        <span class=p>{</span>
          <span class=nt>&#34;range&#34;</span><span class=p>:</span> <span class=p>{</span>
            <span class=nt>&#34;@timestamp&#34;</span><span class=p>:</span> <span class=p>{</span>
              <span class=nt>&#34;gte&#34;</span><span class=p>:</span> <span class=s2>&#34;1544315703107&#34;</span><span class=p>,</span>
              <span class=nt>&#34;lte&#34;</span><span class=p>:</span> <span class=s2>&#34;1544445303107&#34;</span><span class=p>,</span>
              <span class=nt>&#34;format&#34;</span><span class=p>:</span> <span class=s2>&#34;epoch_millis&#34;</span>
            <span class=p>}</span>
          <span class=p>}</span>
        <span class=p>}</span><span class=p>,</span>
        <span class=p>{</span>
          <span class=nt>&#34;query_string&#34;</span><span class=p>:</span> <span class=p>{</span>
            <span class=nt>&#34;analyze_wildcard&#34;</span><span class=p>:</span> <span class=kc>true</span><span class=p>,</span>
            <span class=nt>&#34;query&#34;</span><span class=p>:</span> <span class=s2>&#34;(header.senderId:www1 OR header.senderId:www1 OR header.senderId:www2)&#34;</span>
          <span class=p>}</span>
        <span class=p>}</span>
      <span class=p>]</span>
    <span class=p>}</span>
  <span class=p>}</span>
  <span class=s2>&#34;...&#34;</span><span class=p>:</span> <span class=s2>&#34;...&#34;</span>
<span class=p>}</span>
</code></pre></div><p>The tricky section was that the host filter included over 30 servers
(hostnames). <em>The original query also included a couple of more conditions that
we can disregard for the sake of this article</em>. Of course, executing this over
19M documents it is expensive and time-consuming (even for ES). The
<code>query_string</code> is not very optimal for filtering data. If we look at the
&ldquo;internal query&rdquo; that ES will execute we see something like:</p><div class=highlight><pre class=chroma><code class=language-json data-lang=json><span class=p>{</span>
  <span class=nt>&#34;valid&#34;</span> <span class=p>:</span> <span class=kc>true</span><span class=p>,</span>
  <span class=nt>&#34;explanations&#34;</span> <span class=p>:</span> <span class=p>[</span>
    <span class=p>{</span>
      <span class=nt>&#34;index&#34;</span> <span class=p>:</span> <span class=s2>&#34;accesslogs-2018.12.10&#34;</span><span class=p>,</span>
      <span class=nt>&#34;valid&#34;</span> <span class=p>:</span> <span class=kc>true</span><span class=p>,</span>
      <span class=nt>&#34;explanation&#34;</span> <span class=p>:</span> <span class=s2>&#34;#@timestamp:[1544315703107 TO 1544445303107]
</span><span class=s2>                      #(+(header.senderId:www1 header.senderId:www2 ... )&#34;</span>
    <span class=p>}</span>
  <span class=p>]</span>
<span class=p>}</span>
</code></pre></div><p>This means that internally ES will treat this as a boolean query and will execute
that query against every document that falls in the time range. Even after
Grafana selected the right indices to query, this was a lot of processing to
do. Can we find a better way to write this query?</p><p>If we take the very long list of hosts and apply that as a <code>must</code> filter:</p><div class=highlight><pre class=chroma><code class=language-json data-lang=json><span class=p>{</span>
  <span class=nt>&#34;query&#34;</span><span class=p>:</span> <span class=p>{</span>
    <span class=nt>&#34;bool&#34;</span><span class=p>:</span> <span class=p>{</span>
      <span class=nt>&#34;filter&#34;</span><span class=p>:</span> <span class=p>{</span>
        <span class=nt>&#34;bool&#34;</span><span class=p>:</span> <span class=p>{</span>
          <span class=nt>&#34;must&#34;</span><span class=p>:</span> <span class=p>[</span>
            <span class=p>{</span>
              <span class=nt>&#34;terms&#34;</span><span class=p>:</span> <span class=p>{</span>
                <span class=nt>&#34;header.senderId&#34;</span><span class=p>:</span> <span class=p>[</span>
                  <span class=s2>&#34;www1&#34;</span><span class=p>,</span>
                  <span class=s2>&#34;www2&#34;</span><span class=p>,</span>
                  <span class=err>.</span><span class=err>.</span><span class=err>.</span>
                <span class=p>]</span>
              <span class=p>}</span>
            <span class=p>}</span><span class=p>,</span>
            <span class=p>{</span>
              <span class=nt>&#34;range&#34;</span><span class=p>:</span> <span class=p>{</span>
                <span class=nt>&#34;@timestamp&#34;</span><span class=p>:</span> <span class=p>{</span>
                  <span class=nt>&#34;gte&#34;</span><span class=p>:</span> <span class=s2>&#34;1544315703107&#34;</span><span class=p>,</span>
                  <span class=nt>&#34;lte&#34;</span><span class=p>:</span> <span class=s2>&#34;1544445303107&#34;</span><span class=p>,</span>
                  <span class=nt>&#34;format&#34;</span><span class=p>:</span> <span class=s2>&#34;epoch_millis&#34;</span>
                <span class=p>}</span>
              <span class=p>}</span>
            <span class=p>}</span>
          <span class=p>]</span>
        <span class=p>}</span>
      <span class=p>}</span>
    <span class=p>}</span>
  <span class=p>}</span>
<span class=p>}</span>
</code></pre></div><p>And check the internal query that ES will execute in the profiler:</p><pre><code>&quot;valid&quot; : true,
  &quot;explanations&quot; : [
    {
      &quot;index&quot; : &quot;accesslogs-2018.12.10&quot;,
      &quot;valid&quot; : true,
      &quot;explanation&quot; : &quot;(ConstantScore(+
                      @timestamp:[1544315703107 TO 1544445303107]
                      +header.senderId:(www1 www2 ...)))^0.0&quot;
    }
  ]
</code></pre><p>The explanation section is very different. First of all, we
see that when we use the filter everything is wrapped in <code>ConstantScore</code>,
meaning that no scoring will be performed (we just want to include/exclude data
based on certain criteria). Since the first query is a <code>BooleanQuery</code> for every
<code>OR</code> condition that we've in our query, ES will need to execute a <code>TermQuery</code>,
<em>for each individual condition</em>. But when using a filter, this goes down to a
<code>TermInQuerySet</code>, which means that we save some processing time.</p><p>The other benefit of using filters is that the result set (document ids) will
be cached. This is even more important if you've several Grafana panels that
apply the same filters.</p><p>After running the new query through the profiler we can see some improvement:</p><p><img src=/images/elasticsearch-indices-grafana/query-with-filters-profile.png alt="Query profile, with Filters" title="Profile of the query with filters, showing some improvement"></p><blockquote><p>The difference is even more easy to spot if we remove the <code>range</code> filter.
Removing the <code>range</code> filter forces ES to hit all the documents in the index.
This means that the larger the size of the index, the larger the difference
between both queries will be.</p></blockquote><h2 id=elasticsearch-aliases>Elasticsearch aliases</h2><p>The solution is clear, let's use filters!. And here is where we hit a wall.
At the moment there is no way of specifying query filters for ES in Grafana,
there is an <a href=https://github.com/grafana/grafana/issues/12447>open issue</a> that
has not been addressed yet.</p><p>Elasticsearch supports the use of
<a href=https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-aliases.html><em>aliases</em></a>.
This allows having a different name of referencing some index. Think on a pointer
to an actual index (very similar to a symbolic link). What is even more
powerful is that we can have
<a href=https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-aliases.html#filtered><em>filtered aliases</em></a>.</p><p>According to the documentation:</p><blockquote><p>Aliases with filters provide an easy way to create different &ldquo;views&rdquo; of the
same index.</p></blockquote><p>This means that we could create an alias of our index that automatically
applies the desired filter (the very long list of hosts). Configure this as a
data source in Grafana/Kibana and point our dashboards to use it. With this
feature, we can work around the lack of proper filters for Elasticsearch in
Grafana.</p><p>To create the alias we can fire a <code>POST</code> request against the <code>/_aliases</code> endpoint:</p><pre><code>POST /_aliases
{
  &quot;actions&quot;: [
    {
      &quot;add&quot;: {
        &quot;index&quot;: &quot;accesslogs*&quot;,
        &quot;alias&quot;: &quot;accesslogs-nsi&quot;,
        &quot;filter&quot;: {
          &quot;bool&quot;: {
            &quot;must_not&quot;: [
              {
                &quot;terms&quot;: {
                  &quot;header.senderId&quot;: [
                    &quot;www1&quot;,
                    &quot;www2&quot;,
                    ...
                  ]
                }
              }
            ]
          }
        }
      }
    }
  ]
}
</code></pre><p>The end result: after making the switch in the Grafana panels, the
loading time for the dashboard went down from ~7s to ~2s.</p><p>Additionally, this approach provides some abstraction. Everyone using the
created alias will apply the same set of filters. This provides uniformity and
also enforces good practices. Our users have now a different &ldquo;view&rdquo; of the data
(as stated in the ES documentation).</p><h2 id=summary>Summary</h2><p>Index aliases are a very useful technique not only useful for ingesting without
downtime, but also to offer different &ldquo;views&rdquo; of the same data. As a bonus, they
could help to speed some Grafana dashboards 😉.</p><h2 id=bonus-track-updating-the-aliases>Bonus Track: Updating the aliases</h2><p>Since the aliases are set on the index itself we need to update the alias every
day (when a new index is created). Using <a href=https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-templates.html>index
templates</a>
we can do this. The funny thing is that although we think as an alias
that points to specific indices, internally is the index the one that knows to
which alias (or aliases) it responds to 😀.</p></section></article><footer id=post-meta class=clearfix><svg class="avatar" width="50" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="#cbd5e0" d="M20.3 12.04l1.01 3a1 1 0 01-1.26 1.27l-3.01-1a7 7 0 113.27-3.27zM11 10a1 1 0 100-2 1 1 0 000 2zm3 0a1 1 0 100-2 1 1 0 000 2zm3 0a1 1 0 100-2 1 1 0 000 2z"/><path fill="#4a5568" d="M15.88 17.8a7 7 0 01-8.92 2.5l-3 1.01a1 1 0 01-1.27-1.26l1-3.01A6.97 6.97.0 015 9.1a9 9 0 0010.88 8.7z"/></svg><a href=https://twitter.com/jorgelbg><div><span class=dark>Want to leave a comment?</span>
<span>Drop me a message on Twitter @jorgelbg</span></div></a><section id=sharing><a class=twitter target=_blank href="https://twitter.com/intent/tweet?text=%2f%2fjorgelbg.me%2f2018%2f12%2foptimize-grafana-dashboards-with-elasticsearch-index-aliases%2f - Optimize%20Grafana%20dashboards%20with%20Elasticsearch%20index%20aliases by @jorgelbg"><span class=icon-twitter>tweet</span></a></section></footer><ul id=post-list class="archive readmore"><h3>Read more</h3><li><a href=/2019/05/how-to-rename-index-patterns-in-kibana/><span>How to rename index patterns in Kibana</span><aside class=dates>May 21 2019</aside></a></li><li><a href=/2019/03/useful-alerts-with-elastic-watcher-machine-learning/><span>Useful alerts with Elastic Watcher & Machine Learning</span><aside class=dates>Mar 15 2019</aside></a></li><li><a href=/2019/02/display-the-applications-version-in-your-grafana-dashboards/><span>Display the application's version in your Grafana dashboards</span><aside class=dates>Feb 17 2019</aside></a></li></ul><footer id=footer><p class=small>© Copyright 2020 Jorge Luis Betancourt</p><p class="small cc">Icons made by
<a href=https://www.freepik.com/ title=Freepik>Freepik</a> from
<a href=https://www.flaticon.com/ title=Flaticon>www.flaticon.com</a> is
licensed by
<a href=https://creativecommons.org/licenses/by/3.0/ title="Creative Commons BY 3.0" target=_blank>CC 3.0 BY</a></p></footer></section><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-115201846-1','auto');ga('send','pageview');}</script></body></html>