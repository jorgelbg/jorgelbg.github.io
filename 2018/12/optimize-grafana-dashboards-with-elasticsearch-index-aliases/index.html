<!DOCTYPE html>
<html lang="en-us">
	<head>
    <link rel="stylesheet" href="//jorgelbg.me/css/style.css">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="author" content="Jorge Luis Betancourt">
<meta name="description" content="Computo Ergo Sum">
<meta name="generator" content="Hugo 0.56.2" />
<title>Optimize Grafana dashboards with Elasticsearch index aliases</title>
<link rel="shortcut icon" href="//jorgelbg.me/images/favicon.ico">
<link rel="dns-prefetch" href="//www.google-analytics.com/" />



<link href="//jorgelbg.me/index.xml" rel="alternate" type="application/rss+xml" title="Jorge Luis Betancourt" />


<meta property="og:title" content="Optimize Grafana dashboards with Elasticsearch index aliases" />
<meta property="og:description" content="Elasticsearch aliases can apply filters automatically to your queries.  Let&#39;s use it to speed up some Grafana dashboards.&#34;
" />
<meta property="og:type" content="article" />
<meta property="og:url" content="//jorgelbg.me/2018/12/optimize-grafana-dashboards-with-elasticsearch-index-aliases/" />
<meta property="article:published_time" content="2018-12-20T00:00:00+01:00" />
<meta property="article:modified_time" content="2018-12-20T00:00:00+01:00" />


<meta itemprop="name" content="Optimize Grafana dashboards with Elasticsearch index aliases">
<meta itemprop="description" content="Elasticsearch aliases can apply filters automatically to your queries.  Let&#39;s use it to speed up some Grafana dashboards.&#34;
">


<meta itemprop="datePublished" content="2018-12-20T00:00:00&#43;01:00" />
<meta itemprop="dateModified" content="2018-12-20T00:00:00&#43;01:00" />
<meta itemprop="wordCount" content="1597">



<meta itemprop="keywords" content="grafana,elasticsearch," />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Optimize Grafana dashboards with Elasticsearch index aliases"/>
<meta name="twitter:description" content="Elasticsearch aliases can apply filters automatically to your queries.  Let&#39;s use it to speed up some Grafana dashboards.&#34;
"/>
<meta name="twitter:site" content="@https://twitter.com/jorgelbg"/>


    </head>
<body>
    
    <div class="first">
        <svg class="background" preserveAspectRatio="none" viewBox="0 0 1441 200"><path class="darkline" d="M.096 0H1440l-.096 9.249c-68.201 22.68-149.936 36.746-245.204 42.198C857.665 70.738 893.061 150 719.952 150c-97.684 0-194.212-85.308-276.235-85.308-82.023 0-91.028 22.856-156.68 22.856-43.767 0-139.446-26.1-287.037-78.299L.096 0z" fill="#5A67D8" opacity=".496"/><path class="lightline" d="M.096 0H1440l-.096 9.249c-55.851 37.67-100.093 56.505-132.726 56.505-48.95 0-119.392-28.004-171.378-28.004-141.74 0-95.702 96.212-265.672 66.73C813.408 94.644 759.202 65.748 719 65.755c-40.202.007-127.08 38.727-183.209 38.727-97.684 0-132.197-66.731-214.22-66.731S189.071 75 147.327 75C119.497 75 70.387 53.083 0 9.249L.096 0z" fill="#8564F2" opacity=".628"/></svg>
        
    </div>
    
    <section id="wrapper">
        <nav class="main-nav">
	
		<a href='//jorgelbg.me'>
			
			
			<svg fill="#718096" xmlns="http://www.w3.org/2000/svg" width="48" viewBox="0 0 24 24" height="48"><path class="heroicon-ui" d="M13 20v-5h-2v5a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2v-7.59l-.3.3a1 1 0 1 1-1.4-1.42l9-9a1 1 0 0 1 1.4 0l9 9a1 1 0 0 1-1.4 1.42l-.3-.3V20a2 2 0 0 1-2 2h-3a2 2 0 0 1-2-2zm5 0v-9.59l-6-6-6 6V20h3v-5c0-1.1.9-2 2-2h2a2 2 0 0 1 2 2v5h3z"/></svg>
			
		</a>
	

	

	
</nav>

        
<article class="post">
    <header>
        <h1>
            <a href="/2018/12/optimize-grafana-dashboards-with-elasticsearch-index-aliases/">
            <svg width="30" xmlns="http://www.w3.org/2000/svg" version="1" viewBox="0 0 483 483"><path d="M255 209c-5 6-5 14 0 19 22 22 22 58 0 80L140 423a56 56 0 0 1-79 0l-18-17a56 56 0 0 1 0-80l115-115c6-5 6-14 1-19s-14-5-20 0L24 307a83 83 0 0 0 0 118l18 17a83 83 0 0 0 117 0l115-115c33-32 33-85 0-118-5-5-13-5-19 0z"/><path d="M459 58l-18-17a83 83 0 0 0-117 0L209 156a83 83 0 0 0 0 118c5 5 13 5 19 0s5-14 0-20a56 56 0 0 1 0-79L343 60c22-22 57-22 79 0l17 17c22 22 22 58 0 80L324 272c-5 5-5 13 0 19 3 2 7 4 10 4s7-1 9-4l115-115a83 83 0 0 0 1-118z"/></svg>
            Optimize Grafana dashboards with Elasticsearch index aliases
        </a></h1>
        <h2 class="headline">
            December 20, 2018
            <br>
            <br>
            
            
                
                <span class="tag">
                    <svg fill="#718096" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16"><path class="heroicon-ui" d="M2.59 13.41A1.98 1.98 0 0 1 2 12V7a5 5 0 0 1 5-5h4.99c.53 0 1.04.2 1.42.59l8 8a2 2 0 0 1 0 2.82l-8 8a2 2 0 0 1-2.82 0l-8-8zM20 12l-8-8H7a3 3 0 0 0-3 3v5l8 8 8-8zM7 8a1 1 0 1 1 0-2 1 1 0 0 1 0 2z"/></svg>
                    <a style="margin-left: 10px;" href="//jorgelbg.me/tags/grafana">grafana</a>
                </span>
                
                <span class="tag">
                    <svg fill="#718096" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16"><path class="heroicon-ui" d="M2.59 13.41A1.98 1.98 0 0 1 2 12V7a5 5 0 0 1 5-5h4.99c.53 0 1.04.2 1.42.59l8 8a2 2 0 0 1 0 2.82l-8 8a2 2 0 0 1-2.82 0l-8-8zM20 12l-8-8H7a3 3 0 0 0-3 3v5l8 8 8-8zM7 8a1 1 0 1 1 0-2 1 1 0 0 1 0 2z"/></svg>
                    <a style="margin-left: 10px;" href="//jorgelbg.me/tags/elasticsearch">elasticsearch</a>
                </span>
                
            
            
        </h2>
    </header>
    <section id="post-body">
        

<p>Grafana is a very popular opensource dashboarding solution. Provides support
for a long list of storage solutions, including Elasticsearch.
Unfortunately, the ES support is not at the same level as the one you get for
InfluxDB, for instance. Still, Grafana allows combining in the same
dashboard different data sources. It is possible to have a panel fetching data
from ES and a different panel fetching data from InfluxDB.</p>

<h2 id="grafana-elasticsearch">Grafana ‚ù§Ô∏è Elasticsearch</h2>

<p>Grafana provides stellar support for <a href="https://www.influxdata.com/">InfluxDB</a>
&amp; <a href="http://docs.grafana.org/features/datasources/prometheus/">Prometheus</a>,
among others. This means that you get, query autocompletion for fields, values,
etc. When you select ES as a data source for a panel, the features are a bit less
polished. You are greet by a &ldquo;Lucene query&rdquo; input and some more options.
Depending on the metric (aggregation), Grafana also provides some help
for field name selection when using ES as a data source.</p>

<p>Up to this point, everything is ok, Elasticsearch is not a first citizen in the
Grafana ecosystem, but it&rsquo;s supported and maintained). The issue
that we had a few days ago (and that inspired the content of this post) was
instead related to the query that Grafana sends to ES.</p>

<p>Let&rsquo;s say that we want to calculate the average of a <code>memcache</code> field in a
specific index stored in ES. Only for a subset of our hosts (those that start
with <code>www</code>). Using a Lucene syntax we can &ldquo;filter&rdquo; to only a subset of the
hosts with the following query:</p>

<pre><code>header.senderId:www*
</code></pre>

<p>We could put the same query in a Grafana panel, and we end up with
something like this:</p>

<p><img src="/images/elasticsearch-indices-grafana/grafana-example-query.png" alt="Grafana Example Elasticsearch query" title="Example of a Grafana Elasticsearch query in a panel" /></p>

<p>If we check the <a href="http://docs.grafana.org/guides/whats-new-in-v4-5/#query-inspector">Query Inspector</a>
we can see the query that Grafana sends to ES (actually to the proxy, but
this detail is not important). The relevant section is the
<code>request.data</code> attribute, that looks like:</p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
  <span class="nt">&#34;size&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="nt">&#34;query&#34;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&#34;bool&#34;</span><span class="p">:</span> <span class="p">{</span>
      <span class="nt">&#34;filter&#34;</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
          <span class="nt">&#34;range&#34;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&#34;@timestamp&#34;</span><span class="p">:</span> <span class="p">{</span>
              <span class="nt">&#34;gte&#34;</span><span class="p">:</span> <span class="s2">&#34;1544518226265&#34;</span><span class="p">,</span>
              <span class="nt">&#34;lte&#34;</span><span class="p">:</span> <span class="s2">&#34;1544539826265&#34;</span><span class="p">,</span>
              <span class="nt">&#34;format&#34;</span><span class="p">:</span> <span class="s2">&#34;epoch_millis&#34;</span>
            <span class="p">}</span>
          <span class="p">}</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="nt">&#34;query_string&#34;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&#34;analyze_wildcard&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
            <span class="nt">&#34;query&#34;</span><span class="p">:</span> <span class="s2">&#34;header.senderId:www*&#34;</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">]</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="nt">&#34;aggs&#34;</span><span class="p">:</span> <span class="p">{</span>
      <span class="nt">&#34;...&#34;</span><span class="p">:</span> <span class="s2">&#34;...&#34;</span><span class="p">,</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>We can see that Grafana is applying a
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.5/query-dsl-filtered-query.html">Filtered Query</a>.
One small detail is that whatever we put in our &ldquo;Lucene query&rdquo; input field will
be placed in the <code>query_string</code> section, as an extra <em>filter</em>. This is
great for 90% of the queries, the problem is that if you&rsquo;re querying a large
enough dataset (let&rsquo;s say you want to aggregate over 19M documents), and you&rsquo;re
applying a lot of filters (like searching for specific hosts). This can have an
impact on the performance of your query.</p>

<blockquote>
<p>Not everything is bad if you&rsquo;re using a time-based index pattern, and your
Elasticsearch data source in Grafana is properly configured, Grafana will know
to which indexes send the query depending on the time range, pretty cool!.</p>
</blockquote>

<h2 id="the-problem">The problem</h2>

<p>So far, we&rsquo;ve talked only about how Grafana works. One of our users reported
that from time to time a specific Grafana dashboard would be slow while
fetching data from ES. We saw this issue in our internal monitoring as well:</p>

<p><img src="/images/elasticsearch-indices-grafana/periodic-query-time-spike.png" alt="Periodic spikes in Elasticsearch response times" title="Periodic spikes in Elasticsearch response times shown in the internal monitoring" /></p>

<p>This graph shows that approximately every hour we had a spike in the ES query
time, spiking to ~7s. After some detective work, one coworker found the
culprit dashboard. Considering that the query was executing periodically, it was
a good bet that the query was coming from some sort of automated source (like a
dashboard put in a rotation).</p>

<p>After identifying the problematic query we realized that the query was hitting
a lot of unnecessary shards (last 30 days). We fix it by
configuring the data source to use the daily pattern. This helped with reducing
the number of shards that the query hit. Still, it didn&rsquo;t impact
<em>significantly</em> the response time of the query. This is a testimony
of how efficient ES/Lucene is.</p>

<h2 id="time-to-profile">Time to profile</h2>

<p>At this point, there is not a lot of things that we can do, except profiling the
query. Kibana comes bundled with a
<a href="https://www.elastic.co/guide/en/kibana/current/xpack-profiler.html">Search Profiler</a>
with the basic version of X-pack. Putting the query in the profiler and hitting
the <kbd>Profile</kbd> button already provided a lot of insight:</p>

<p><img src="/images/elasticsearch-indices-grafana/original-query-profile.png" alt="Profile of the original Grafana query" title="Profiling of the original query taking a long time" /></p>

<p>To reduce the noise introduced. we decided to query one specific index. For 1
day of data the query that Grafana was sending to ES was taking ~40s <strong>(inside
the profiler)</strong>. Of course, a significant part of this time comes from the
profiling itself. We knew that on production for the last 2 days this time
was ~7s. So we decided to use the 40s as a base reference.</p>

<p>The real query looked very similar to:</p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
  <span class="nt">&#34;size&#34;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
  <span class="nt">&#34;query&#34;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&#34;bool&#34;</span><span class="p">:</span> <span class="p">{</span>
      <span class="nt">&#34;filter&#34;</span><span class="p">:</span> <span class="p">[</span>
        <span class="p">{</span>
          <span class="nt">&#34;range&#34;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&#34;@timestamp&#34;</span><span class="p">:</span> <span class="p">{</span>
              <span class="nt">&#34;gte&#34;</span><span class="p">:</span> <span class="s2">&#34;1544315703107&#34;</span><span class="p">,</span>
              <span class="nt">&#34;lte&#34;</span><span class="p">:</span> <span class="s2">&#34;1544445303107&#34;</span><span class="p">,</span>
              <span class="nt">&#34;format&#34;</span><span class="p">:</span> <span class="s2">&#34;epoch_millis&#34;</span>
            <span class="p">}</span>
          <span class="p">}</span>
        <span class="p">},</span>
        <span class="p">{</span>
          <span class="nt">&#34;query_string&#34;</span><span class="p">:</span> <span class="p">{</span>
            <span class="nt">&#34;analyze_wildcard&#34;</span><span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
            <span class="nt">&#34;query&#34;</span><span class="p">:</span> <span class="s2">&#34;(header.senderId:www1 OR header.senderId:www1 OR header.senderId:www2)&#34;</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">]</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="s2">&#34;...&#34;</span><span class="p">:</span> <span class="s2">&#34;...&#34;</span>
<span class="p">}</span></code></pre></div>
<p>The tricky section was that the host filter included over 30 servers
(hostnames). <em>The original query also included a couple of more conditions that
we can disregard for the sake of this article</em>. Of course, executing this over
19M documents it is expensive and time-consuming (even for ES). The
<code>query_string</code> is not very optimal for filtering data. If we look at the
&ldquo;internal query&rdquo; that ES will execute we see something like:</p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
  <span class="nt">&#34;valid&#34;</span> <span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
  <span class="nt">&#34;explanations&#34;</span> <span class="p">:</span> <span class="p">[</span>
    <span class="p">{</span>
      <span class="nt">&#34;index&#34;</span> <span class="p">:</span> <span class="s2">&#34;accesslogs-2018.12.10&#34;</span><span class="p">,</span>
      <span class="nt">&#34;valid&#34;</span> <span class="p">:</span> <span class="kc">true</span><span class="p">,</span>
      <span class="nt">&#34;explanation&#34;</span> <span class="p">:</span> <span class="s2">&#34;#@timestamp:[1544315703107 TO 1544445303107] 
</span><span class="s2">                      #(+(header.senderId:www1 header.senderId:www2 ... )&#34;</span>
    <span class="p">}</span>
  <span class="p">]</span>
<span class="p">}</span></code></pre></div>
<p>This means that internally ES will treat this as a boolean query and will execute
that query against every document that falls in the time range. Even after
Grafana selected the right indices to query, this was a lot of processing to
do. Can we find a better way to write this query?</p>

<p>If we take the very long list of hosts and apply that as a <code>must</code> filter:</p>
<div class="highlight"><pre class="chroma"><code class="language-json" data-lang="json"><span class="p">{</span>
  <span class="nt">&#34;query&#34;</span><span class="p">:</span> <span class="p">{</span>
    <span class="nt">&#34;bool&#34;</span><span class="p">:</span> <span class="p">{</span>
      <span class="nt">&#34;filter&#34;</span><span class="p">:</span> <span class="p">{</span>
        <span class="nt">&#34;bool&#34;</span><span class="p">:</span> <span class="p">{</span>
          <span class="nt">&#34;must&#34;</span><span class="p">:</span> <span class="p">[</span>
            <span class="p">{</span>
              <span class="nt">&#34;terms&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;header.senderId&#34;</span><span class="p">:</span> <span class="p">[</span>
                  <span class="s2">&#34;www1&#34;</span><span class="p">,</span>
                  <span class="s2">&#34;www2&#34;</span><span class="p">,</span>
                  <span class="err">...</span>
                <span class="p">]</span>
              <span class="p">}</span>
            <span class="p">},</span>
            <span class="p">{</span>
              <span class="nt">&#34;range&#34;</span><span class="p">:</span> <span class="p">{</span>
                <span class="nt">&#34;@timestamp&#34;</span><span class="p">:</span> <span class="p">{</span>
                  <span class="nt">&#34;gte&#34;</span><span class="p">:</span> <span class="s2">&#34;1544315703107&#34;</span><span class="p">,</span>
                  <span class="nt">&#34;lte&#34;</span><span class="p">:</span> <span class="s2">&#34;1544445303107&#34;</span><span class="p">,</span>
                  <span class="nt">&#34;format&#34;</span><span class="p">:</span> <span class="s2">&#34;epoch_millis&#34;</span>
                <span class="p">}</span>
              <span class="p">}</span>
            <span class="p">}</span>
          <span class="p">]</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span></code></pre></div>
<p>And check the internal query that ES will execute in the profiler:</p>

<pre><code>&quot;valid&quot; : true,
  &quot;explanations&quot; : [
    {
      &quot;index&quot; : &quot;accesslogs-2018.12.10&quot;,
      &quot;valid&quot; : true,
      &quot;explanation&quot; : &quot;(ConstantScore(+
                      @timestamp:[1544315703107 TO 1544445303107] 
                      +header.senderId:(www1 www2 ...)))^0.0&quot;
    }
  ]
</code></pre>

<p>The explanation section is very different. First of all, we
see that when we use the filter everything is wrapped in <code>ConstantScore</code>,
meaning that no scoring will be performed (we just want to include/exclude data
based on certain criteria). Since the first query is a <code>BooleanQuery</code> for every
<code>OR</code> condition that we&rsquo;ve in our query, ES will need to execute a <code>TermQuery</code>,
<em>for each individual condition</em>. But when using a filter, this goes down to a
<code>TermInQuerySet</code>, which means that we save some processing time.</p>

<p>The other benefit of using filters is that the result set (document ids) will
be cached. This is even more important if you&rsquo;ve several Grafana panels that
apply the same filters.</p>

<p>After running the new query through the profiler we can see some improvement:</p>

<p><img src="/images/elasticsearch-indices-grafana/query-with-filters-profile.png" alt="Query profile, with Filters" title="Profile of the query with filters, showing some improvement" /></p>

<blockquote>
<p>The difference is even more easy to spot if we remove the <code>range</code> filter.
Removing the <code>range</code> filter forces ES to hit all the documents in the index.
This means that the larger the size of the index, the larger the difference
between both queries will be.</p>
</blockquote>

<h2 id="elasticsearch-aliases">Elasticsearch aliases</h2>

<p>The solution is clear, let&rsquo;s use filters!. And here is where we hit a wall.
At the moment there is no way of specifying query filters for ES in Grafana,
there is an <a href="https://github.com/grafana/grafana/issues/12447">open issue</a> that
has not been addressed yet.</p>

<figure>
    <img src="/images/elasticsearch-indices-grafana/filter-all-the-things.jpg#center"/> 
</figure>

<p>Elasticsearch supports the use of
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-aliases.html"><em>aliases</em></a>.
This allows having a different name of referencing some index. Think on a pointer
to an actual index (very similar to a symbolic link). What is even more
powerful is that we can have
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-aliases.html#filtered"><em>filtered aliases</em></a>.</p>

<p>According to the documentation:</p>

<blockquote>
<p>Aliases with filters provide an easy way to create different &ldquo;views&rdquo; of the
same index.</p>
</blockquote>

<p>This means that we could create an alias of our index that automatically
applies the desired filter (the very long list of hosts). Configure this as a
data source in Grafana/Kibana and point our dashboards to use it. With this
feature, we can work around the lack of proper filters for Elasticsearch in
Grafana.</p>

<p>To create the alias we can fire a <code>POST</code> request against the <code>/_aliases</code> endpoint:</p>

<pre><code>POST /_aliases
{
  &quot;actions&quot;: [
    {
      &quot;add&quot;: {
        &quot;index&quot;: &quot;accesslogs*&quot;,
        &quot;alias&quot;: &quot;accesslogs-nsi&quot;,
        &quot;filter&quot;: {
          &quot;bool&quot;: {
            &quot;must_not&quot;: [
              {
                &quot;terms&quot;: {
                  &quot;header.senderId&quot;: [
                    &quot;www1&quot;,
                    &quot;www2&quot;,
                    ...
                  ]
                }
              }
            ]
          }
        }
      }
    }
  ]
}
</code></pre>

<p>The end result: after making the switch in the Grafana panels, the
loading time for the dashboard went down from ~7s to ~2s.</p>

<p>Additionally, this approach provides some abstraction. Everyone using the
created alias will apply the same set of filters. This provides uniformity and
also enforces good practices. Our users have now a different &ldquo;view&rdquo; of the data
(as stated in the ES documentation).</p>

<h2 id="summary">Summary</h2>

<p>Index aliases are a very useful technique not only useful for ingesting without
downtime, but also to offer different &ldquo;views&rdquo; of the same data. As a bonus, they
could help to speed some Grafana dashboards üòâ.</p>

<h2 id="bonus-track-updating-the-aliases">Bonus Track: Updating the aliases</h2>

<p>Since the aliases are set on the index itself we need to update the alias every
day (when a new index is created). Using <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-templates.html">index
templates</a>
we can do this. The funny thing is that although we think as an alias
that points to specific indices, internally is the index the one that knows to
which alias (or aliases) it responds to üòÄ.</p>

    </section>
</article>

<footer id="post-meta" class="clearfix">
    <svg class="avatar" width="50" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
        <path fill="#CBD5E0" d="M20.3 12.04l1.01 3a1 1 0 0 1-1.26 1.27l-3.01-1a7 7 0 1 1 3.27-3.27zM11 10a1 1 0 1 0 0-2 1 1 0 0 0 0 2zm3 0a1 1 0 1 0 0-2 1 1 0 0 0 0 2zm3 0a1 1 0 1 0 0-2 1 1 0 0 0 0 2z"></path>
        <path fill="#4A5568" d="M15.88 17.8a7 7 0 0 1-8.92 2.5l-3 1.01a1 1 0 0 1-1.27-1.26l1-3.01A6.97 6.97 0 0 1 5 9.1a9 9 0 0 0 10.88 8.7z"></path>
    </svg>
    <a href="https://twitter.com/jorgelbg">
    
    <div>
        
        
        <span class="dark">Want to leave a comment?</span>
        <span>Drop me a message on Twitter @jorgelbg </span>
    </div>
    </a>
    <section id="sharing">
        <a class="twitter" target="_blank" href="https://twitter.com/intent/tweet?text=%2f%2fjorgelbg.me%2f2018%2f12%2foptimize-grafana-dashboards-with-elasticsearch-index-aliases%2f - Optimize%20Grafana%20dashboards%20with%20Elasticsearch%20index%20aliases by @jorgelbg"><span class="icon-twitter"> tweet</span></a>



    </section>
</footer>



<ul id="post-list" class="archive readmore">
    <h3>Read more</h3>

    
    
    
        <li>
            <a href="/2019/05/how-to-rename-index-patterns-in-kibana/">How to rename index patterns in Kibana<aside class="dates">May 21 2019</aside></a>
        </li>
    
        <li>
            <a href="/2019/03/useful-alerts-with-elastic-watcher-machine-learning/">Useful alerts with Elastic Watcher &amp; Machine Learning<aside class="dates">Mar 15 2019</aside></a>
        </li>
    
        <li>
            <a href="/2019/02/display-the-applications-version-in-your-grafana-dashboards/">Display the application&#39;s version in your Grafana dashboards<aside class="dates">Feb 17 2019</aside></a>
        </li>
    
</ul>


        <footer id="footer">
  
  <div id="social">
    
    <a class="symbol github" href="https://github.com/jorgelbg">
    
        <svg height="30" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M255.968 5.329C114.624 5.329 0 120.401 0 262.353c0 113.536 73.344 209.856 175.104 243.872 12.8 2.368 17.472-5.568 17.472-12.384 0-6.112-.224-22.272-.352-43.712-71.2 15.52-86.24-34.464-86.24-34.464-11.616-29.696-28.416-37.6-28.416-37.6-23.264-15.936 1.728-15.616 1.728-15.616 25.696 1.824 39.2 26.496 39.2 26.496 22.848 39.264 59.936 27.936 74.528 21.344 2.304-16.608 8.928-27.936 16.256-34.368-56.832-6.496-116.608-28.544-116.608-127.008 0-28.064 9.984-51.008 26.368-68.992-2.656-6.496-11.424-32.64 2.496-68 0 0 21.504-6.912 70.4 26.336 20.416-5.696 42.304-8.544 64.096-8.64 21.728.128 43.648 2.944 64.096 8.672 48.864-33.248 70.336-26.336 70.336-26.336 13.952 35.392 5.184 61.504 2.56 68 16.416 17.984 26.304 40.928 26.304 68.992 0 98.72-59.84 120.448-116.864 126.816 9.184 7.936 17.376 23.616 17.376 47.584 0 34.368-.32 62.08-.32 70.496 0 6.88 4.608 14.88 17.6 12.352C438.72 472.145 512 375.857 512 262.353 512 120.401 397.376 5.329 255.968 5.329z"/></svg>
    
    </a>
    
    <a class="symbol twitter" href="https://twitter.com/jorgelbg">
    
        <svg height="30" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 612 612"><path d="M612 116.258a250.714 250.714 0 0 1-72.088 19.772c25.929-15.527 45.777-40.155 55.184-69.411-24.322 14.379-51.169 24.82-79.775 30.48-22.907-24.437-55.49-39.658-91.63-39.658-69.334 0-125.551 56.217-125.551 125.513 0 9.828 1.109 19.427 3.251 28.606-104.326-5.24-196.835-55.223-258.75-131.174-10.823 18.51-16.98 40.078-16.98 63.101 0 43.559 22.181 81.993 55.835 104.479a125.556 125.556 0 0 1-56.867-15.756v1.568c0 60.806 43.291 111.554 100.693 123.104-10.517 2.83-21.607 4.398-33.08 4.398-8.107 0-15.947-.803-23.634-2.333 15.985 49.907 62.336 86.199 117.253 87.194-42.947 33.654-97.099 53.655-155.916 53.655-10.134 0-20.116-.612-29.944-1.721 55.567 35.681 121.536 56.485 192.438 56.485 230.948 0 357.188-191.291 357.188-357.188l-.421-16.253c24.666-17.593 46.005-39.697 62.794-64.861z" fill="#010002"/></svg>
    
    </a>
    
    
    <a href="//jorgelbg.me/index.xml" class="symbol rss">
        <svg height="28" version="1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 559 559"><path d="M53 0a497 497 0 0 1 358 148 508 508 0 0 1 148 358c0 15-5 27-15 38a51 51 0 0 1-38 15c-15 0-27-5-38-15a51 51 0 0 1-15-38 390 390 0 0 0-117-282A400 400 0 0 0 53 106 52 52 0 0 1 0 53c0-14 5-27 16-37C26 5 39 0 53 0zm0 201c42 0 82 8 119 25s69 37 96 65a312 312 0 0 1 90 215c0 15-5 27-16 38a51 51 0 0 1-37 15c-15 0-27-5-38-15a51 51 0 0 1-15-38 192 192 0 0 0-59-140 201 201 0 0 0-140-58c-14 0-27-5-37-16-11-10-16-23-16-37s5-28 16-38c10-10 23-16 37-16zm98 280a73 73 0 0 1-45 69c-10 4-19 6-30 6a73 73 0 0 1-68-46 74 74 0 0 1 39-98 74 74 0 0 1 104 69z" fill="#010002"/></svg>
    </a>
    
</div>

  
  <p class="small">
    
    ¬© Copyright 2019 Jorge Luis Betancourt
    
  </p>
  <p class="small cc">
    Icons made by
    <a href="https://www.freepik.com/" title="Freepik">Freepik</a> from
    <a href="https://www.flaticon.com/" title="Flaticon">www.flaticon.com</a> is
    licensed by
    <a
      href="https://creativecommons.org/licenses/by/3.0/"
      title="Creative Commons BY 3.0"
      target="_blank"
      >CC 3.0 BY</a
    >
  </p>
</footer>

    </section>
    


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-115201846-1', 'auto');
	
	ga('send', 'pageview');
}
</script>


</body>
</html>
