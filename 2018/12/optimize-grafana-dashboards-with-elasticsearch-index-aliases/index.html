<!DOCTYPE html>
<html lang="en-us">
	<head>
    <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="author" content="Jorge Luis Betancourt">
<meta name="description" content="Computo Ergo Sum">
<meta name="generator" content="Hugo 0.54.0" />
<title>Optimize Grafana dashboards with Elasticsearch index aliases</title>
<link rel="shortcut icon" href="http://jorgelbg.github.io/images/favicon.ico">
<link rel="stylesheet" href="http://jorgelbg.github.io/css/style.css">
<link rel="stylesheet" href="http://jorgelbg.github.io/css/highlight.css">

<link rel="stylesheet" href="http://jorgelbg.github.io/css/custom.css">



<link href="http://jorgelbg.github.io/index.xml" rel="alternate" type="application/rss+xml" title="Jorge Luis Betancourt" />


<meta property="og:title" content="Optimize Grafana dashboards with Elasticsearch index aliases" />
<meta property="og:description" content="Elasticsearch aliases can apply filters automatically to your queries.  Let&#39;s use it to speed up some Grafana dashboards.&#34;
" />
<meta property="og:type" content="article" />
<meta property="og:url" content="http://jorgelbg.github.io/2018/12/optimize-grafana-dashboards-with-elasticsearch-index-aliases/" />
<meta property="article:published_time" content="2018-12-20T00:00:00&#43;01:00"/>
<meta property="article:modified_time" content="2018-12-20T00:00:00&#43;01:00"/>



<meta itemprop="name" content="Optimize Grafana dashboards with Elasticsearch index aliases">
<meta itemprop="description" content="Elasticsearch aliases can apply filters automatically to your queries.  Let&#39;s use it to speed up some Grafana dashboards.&#34;
">


<meta itemprop="datePublished" content="2018-12-20T00:00:00&#43;01:00" />
<meta itemprop="dateModified" content="2018-12-20T00:00:00&#43;01:00" />
<meta itemprop="wordCount" content="1597">



<meta itemprop="keywords" content="" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Optimize Grafana dashboards with Elasticsearch index aliases"/>
<meta name="twitter:description" content="Elasticsearch aliases can apply filters automatically to your queries.  Let&#39;s use it to speed up some Grafana dashboards.&#34;
"/>
<meta name="twitter:site" content="@https://www.twitter.com/jorgelbgm"/>


    </head>
<body>
    <nav class="main-nav">
	
		<a href='http://jorgelbg.github.io/'>
			<svg height="30" fill="#5661B3" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 492 492"><path d="M464.344 207.418l.768.168H135.888l103.496-103.724c5.068-5.064 7.848-11.924 7.848-19.124 0-7.2-2.78-14.012-7.848-19.088L223.28 49.538c-5.064-5.064-11.812-7.864-19.008-7.864-7.2 0-13.952 2.78-19.016 7.844L7.844 226.914C2.76 231.998-.02 238.77 0 245.974c-.02 7.244 2.76 14.02 7.844 19.096l177.412 177.412c5.064 5.06 11.812 7.844 19.016 7.844 7.196 0 13.944-2.788 19.008-7.844l16.104-16.112c5.068-5.056 7.848-11.808 7.848-19.008 0-7.196-2.78-13.592-7.848-18.652L134.72 284.406h329.992c14.828 0 27.288-12.78 27.288-27.6v-22.788c0-14.82-12.828-26.6-27.656-26.6z"/></svg>
			
		</a>
	

	

	
</nav>

    <section id="wrapper">
        
        
<article class="post">
    <header>
        <h1>Optimize Grafana dashboards with Elasticsearch index aliases</h1>
        <h2 class="headline">
            December 20, 2018
            <br>
            
        </h2>
    </header>
    <section id="post-body">
        

<p>Grafana is a very popular opensource dashboarding solution. Provides support
for a long list of storage solutions, including Elasticsearch.
Unfortunately, the ES support is not at the same level as the one you get for
InfluxDB, for instance. Still, Grafana allows combining in the same
dashboard different data sources. It is possible to have a panel fetching data
from ES and a different panel fetching data from InfluxDB.</p>

<h2 id="grafana-elasticsearch">Grafana ❤️ Elasticsearch</h2>

<p>Grafana provides stellar support for <a href="https://www.influxdata.com/">InfluxDB</a>
&amp; <a href="http://docs.grafana.org/features/datasources/prometheus/">Prometheus</a>,
among others. This means that you get, query autocompletion for fields, values,
etc. When you select ES as a data source for a panel, the features are a bit less
polished. You are greet by a &ldquo;Lucene query&rdquo; input and some more options.
Depending on the metric (aggregation), Grafana also provides some help
for field name selection when using ES as a data source.</p>

<p>Up to this point, everything is ok, Elasticsearch is not a first citizen in the
Grafana ecosystem, but it&rsquo;s supported and maintained). The issue
that we had a few days ago (and that inspired the content of this post) was
instead related to the query that Grafana sends to ES.</p>

<p>Let&rsquo;s say that we want to calculate the average of a <code>memcache</code> field in a
specific index stored in ES. Only for a subset of our hosts (those that start
with <code>www</code>). Using a Lucene syntax we can &ldquo;filter&rdquo; to only a subset of the
hosts with the following query:</p>

<pre><code>header.senderId:www*
</code></pre>

<p>We could put the same query in a Grafana panel, and we end up with
something like this:</p>

<p><img src="/images/elasticsearch-indices-grafana/grafana-example-query.png" alt="Grafana Example Elasticsearch query" title="Example of a Grafana Elasticsearch query in a panel" /></p>

<p>If we check the <a href="http://docs.grafana.org/guides/whats-new-in-v4-5/#query-inspector">Query Inspector</a>
we can see the query that Grafana sends to ES (actually to the proxy, but
this detail is not important). The relevant section is the
<code>request.data</code> attribute, that looks like:</p>

<pre><code class="language-json">{
  &quot;size&quot;: 0,
  &quot;query&quot;: {
    &quot;bool&quot;: {
      &quot;filter&quot;: [
        {
          &quot;range&quot;: {
            &quot;@timestamp&quot;: {
              &quot;gte&quot;: &quot;1544518226265&quot;,
              &quot;lte&quot;: &quot;1544539826265&quot;,
              &quot;format&quot;: &quot;epoch_millis&quot;
            }
          }
        },
        {
          &quot;query_string&quot;: {
            &quot;analyze_wildcard&quot;: true,
            &quot;query&quot;: &quot;header.senderId:www*&quot;
          }
        }
      ]
    }
  },
  &quot;aggs&quot;: {
      &quot;...&quot;: &quot;...&quot;,
  }
}
</code></pre>

<p>We can see that Grafana is applying a
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.5/query-dsl-filtered-query.html">Filtered Query</a>.
One small detail is that whatever we put in our &ldquo;Lucene query&rdquo; input field will
be placed in the <code>query_string</code> section, as an extra <em>filter</em>. This is
great for 90% of the queries, the problem is that if you&rsquo;re querying a large
enough dataset (let&rsquo;s say you want to aggregate over 19M documents), and you&rsquo;re
applying a lot of filters (like searching for specific hosts). This can have an
impact on the performance of your query.</p>

<blockquote>
<p>Not everything is bad if you&rsquo;re using a time-based index pattern, and your
Elasticsearch data source in Grafana is properly configured, Grafana will know
to which indexes send the query depending on the time range, pretty cool!.</p>
</blockquote>

<h2 id="the-problem">The problem</h2>

<p>So far, we&rsquo;ve talked only about how Grafana works. One of our users reported
that from time to time a specific Grafana dashboard would be slow while
fetching data from ES. We saw this issue in our internal monitoring as well:</p>

<p><img src="/images/elasticsearch-indices-grafana/periodic-query-time-spike.png" alt="Periodic spikes in Elasticsearch response times" title="Periodic spikes in Elasticsearch response times shown in the internal monitoring" /></p>

<p>This graph shows that approximately every hour we had a spike in the ES query
time, spiking to ~7s. After some detective work, one coworker found the
culprit dashboard. Considering that the query was executing periodically, it was
a good bet that the query was coming from some sort of automated source (like a
dashboard put in a rotation).</p>

<p>After identifying the problematic query we realized that the query was hitting
a lot of unnecessary shards (last 30 days). We fix it by
configuring the data source to use the daily pattern. This helped with reducing
the number of shards that the query hit. Still, it didn&rsquo;t impact
<em>significantly</em> the response time of the query. This is a testimony
of how efficient ES/Lucene is.</p>

<h2 id="time-to-profile">Time to profile</h2>

<p>At this point, there is not a lot of things that we can do, except profiling the
query. Kibana comes bundled with a
<a href="https://www.elastic.co/guide/en/kibana/current/xpack-profiler.html">Search Profiler</a>
with the basic version of X-pack. Putting the query in the profiler and hitting
the <kbd>Profile</kbd> button already provided a lot of insight:</p>

<p><img src="/images/elasticsearch-indices-grafana/original-query-profile.png" alt="Profile of the original Grafana query" title="Profiling of the original query taking a long time" /></p>

<p>To reduce the noise introduced. we decided to query one specific index. For 1
day of data the query that Grafana was sending to ES was taking ~40s <strong>(inside
the profiler)</strong>. Of course, a significant part of this time comes from the
profiling itself. We knew that on production for the last 2 days this time
was ~7s. So we decided to use the 40s as a base reference.</p>

<p>The real query looked very similar to:</p>

<pre><code class="language-json">{
  &quot;size&quot;: 0,
  &quot;query&quot;: {
    &quot;bool&quot;: {
      &quot;filter&quot;: [
        {
          &quot;range&quot;: {
            &quot;@timestamp&quot;: {
              &quot;gte&quot;: &quot;1544315703107&quot;,
              &quot;lte&quot;: &quot;1544445303107&quot;,
              &quot;format&quot;: &quot;epoch_millis&quot;
            }
          }
        },
        {
          &quot;query_string&quot;: {
            &quot;analyze_wildcard&quot;: true,
            &quot;query&quot;: &quot;(header.senderId:www1 OR header.senderId:www1 OR header.senderId:www2)&quot;
          }
        }
      ]
    }
  }
  &quot;...&quot;: &quot;...&quot;
}
</code></pre>

<p>The tricky section was that the host filter included over 30 servers
(hostnames). <em>The original query also included a couple of more conditions that
we can disregard for the sake of this article</em>. Of course, executing this over
19M documents it is expensive and time-consuming (even for ES). The
<code>query_string</code> is not very optimal for filtering data. If we look at the
&ldquo;internal query&rdquo; that ES will execute we see something like:</p>

<pre><code class="language-json">{
  &quot;valid&quot; : true,
  &quot;explanations&quot; : [
    {
      &quot;index&quot; : &quot;accesslogs-2018.12.10&quot;,
      &quot;valid&quot; : true,
      &quot;explanation&quot; : &quot;#@timestamp:[1544315703107 TO 1544445303107] 
                      #(+(header.senderId:www1 header.senderId:www2 ... )&quot;
    }
  ]
}
</code></pre>

<p>This means that internally ES will treat this as a boolean query and will execute
that query against every document that falls in the time range. Even after
Grafana selected the right indices to query, this was a lot of processing to
do. Can we find a better way to write this query?</p>

<p>If we take the very long list of hosts and apply that as a <code>must</code> filter:</p>

<pre><code class="language-json">{
  &quot;query&quot;: {
    &quot;bool&quot;: {
      &quot;filter&quot;: {
        &quot;bool&quot;: {
          &quot;must&quot;: [
            {
              &quot;terms&quot;: {
                &quot;header.senderId&quot;: [
                  &quot;www1&quot;,
                  &quot;www2&quot;,
                  ...
                ]
              }
            },
            {
              &quot;range&quot;: {
                &quot;@timestamp&quot;: {
                  &quot;gte&quot;: &quot;1544315703107&quot;,
                  &quot;lte&quot;: &quot;1544445303107&quot;,
                  &quot;format&quot;: &quot;epoch_millis&quot;
                }
              }
            }
          ]
        }
      }
    }
  }
}
</code></pre>

<p>And check the internal query that ES will execute in the profiler:</p>

<pre><code>&quot;valid&quot; : true,
  &quot;explanations&quot; : [
    {
      &quot;index&quot; : &quot;accesslogs-2018.12.10&quot;,
      &quot;valid&quot; : true,
      &quot;explanation&quot; : &quot;(ConstantScore(+
                      @timestamp:[1544315703107 TO 1544445303107] 
                      +header.senderId:(www1 www2 ...)))^0.0&quot;
    }
  ]
</code></pre>

<p>The explanation section is very different. First of all, we
see that when we use the filter everything is wrapped in <code>ConstantScore</code>,
meaning that no scoring will be performed (we just want to include/exclude data
based on certain criteria). Since the first query is a <code>BooleanQuery</code> for every
<code>OR</code> condition that we&rsquo;ve in our query, ES will need to execute a <code>TermQuery</code>,
<em>for each individual condition</em>. But when using a filter, this goes down to a
<code>TermInQuerySet</code>, which means that we save some processing time.</p>

<p>The other benefit of using filters is that the result set (document ids) will
be cached. This is even more important if you&rsquo;ve several Grafana panels that
apply the same filters.</p>

<p>After running the new query through the profiler we can see some improvement:</p>

<p><img src="/images/elasticsearch-indices-grafana/query-with-filters-profile.png" alt="Query profile, with Filters" title="Profile of the query with filters, showing some improvement" /></p>

<blockquote>
<p>The difference is even more easy to spot if we remove the <code>range</code> filter.
Removing the <code>range</code> filter forces ES to hit all the documents in the index.
This means that the larger the size of the index, the larger the difference
between both queries will be.</p>
</blockquote>

<h2 id="elasticsearch-aliases">Elasticsearch aliases</h2>

<p>The solution is clear, let&rsquo;s use filters!. And here is where we hit a wall.
At the moment there is no way of specifying query filters for ES in Grafana,
there is an <a href="https://github.com/grafana/grafana/issues/12447">open issue</a> that
has not been addressed yet.</p>

<figure>
    <img src="/images/elasticsearch-indices-grafana/filter-all-the-things.jpg#center"/> 
</figure>


<p>Elasticsearch supports the use of
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-aliases.html"><em>aliases</em></a>.
This allows having a different name of referencing some index. Think on a pointer
to an actual index (very similar to a symbolic link). What is even more
powerful is that we can have
<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-aliases.html#filtered"><em>filtered aliases</em></a>.</p>

<p>According to the documentation:</p>

<blockquote>
<p>Aliases with filters provide an easy way to create different &ldquo;views&rdquo; of the
same index.</p>
</blockquote>

<p>This means that we could create an alias of our index that automatically
applies the desired filter (the very long list of hosts). Configure this as a
data source in Grafana/Kibana and point our dashboards to use it. With this
feature, we can work around the lack of proper filters for Elasticsearch in
Grafana.</p>

<p>To create the alias we can fire a <code>POST</code> request against the <code>/_aliases</code> endpoint:</p>

<pre><code>POST /_aliases
{
  &quot;actions&quot;: [
    {
      &quot;add&quot;: {
        &quot;index&quot;: &quot;accesslogs*&quot;,
        &quot;alias&quot;: &quot;accesslogs-nsi&quot;,
        &quot;filter&quot;: {
          &quot;bool&quot;: {
            &quot;must_not&quot;: [
              {
                &quot;terms&quot;: {
                  &quot;header.senderId&quot;: [
                    &quot;www1&quot;,
                    &quot;www2&quot;,
                    ...
                  ]
                }
              }
            ]
          }
        }
      }
    }
  ]
}
</code></pre>

<p>The end result: after making the switch in the Grafana panels, the
loading time for the dashboard went down from ~7s to ~2s.</p>

<p>Additionally, this approach provides some abstraction. Everyone using the
created alias will apply the same set of filters. This provides uniformity and
also enforces good practices. Our users have now a different &ldquo;view&rdquo; of the data
(as stated in the ES documentation).</p>

<h2 id="summary">Summary</h2>

<p>Index aliases are a very useful technique not only useful for ingesting without
downtime, but also to offer different &ldquo;views&rdquo; of the same data. As a bonus, they
could help to speed some Grafana dashboards 😉.</p>

<h2 id="bonus-track-updating-the-aliases">Bonus Track: Updating the aliases</h2>

<p>Since the aliases are set on the index itself we need to update the alias every
day (when a new index is created). Using <a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-templates.html">index
templates</a>
we can do this. The funny thing is that although we think as an alias
that points to specific indices, internally is the index the one that knows to
which alias (or aliases) it responds to 😀.</p>

    </section>
</article>

<footer id="post-meta" class="clearfix">
    <a href="https://twitter.com/jorgelbg">
    <img class="avatar" src="http://jorgelbg.github.io/images/avatar.png">
    <div>
        <span class="dark">Jorge Luis Betancourt</span>
        <span>Software engineer with a passion for data, search and performance</span>
    </div>
    </a>
    <section id="sharing">
        <a class="twitter" href="https://twitter.com/intent/tweet?text=http%3a%2f%2fjorgelbg.github.io%2f2018%2f12%2foptimize-grafana-dashboards-with-elasticsearch-index-aliases%2f - Optimize%20Grafana%20dashboards%20with%20Elasticsearch%20index%20aliases by @jorgelbg"><span class="icon-twitter"> tweet</span></a>

<a class="facebook" href="#" onclick="
    window.open(
      'https://www.facebook.com/sharer/sharer.php?u='+encodeURIComponent(location.href),
      'facebook-share-dialog',
      'width=626,height=436');
    return false;"><span class="icon-facebook-rect"> Share</span>
</a>

    </section>
</footer>



<ul id="post-list" class="archive readmore">
    <h3>Read more</h3>

    
    
    
        <li>
            <a href="/2019/03/useful-alerts-with-elastic-watcher-machine-learning/">Useful alerts with Elastic Watcher &amp; Machine Learning<aside class="dates">Mar 15 2019</aside></a>
        </li>
    
        <li>
            <a href="/2019/02/display-the-applications-version-in-your-grafana-dashboards/">Display the application&#39;s version in your Grafana dashboards<aside class="dates">Feb 17 2019</aside></a>
        </li>
    
        <li>
            <a href="/2018/08/logs-and-metrics-for-small-data/">Logs and metrics for Small Data<aside class="dates">Aug 23 2018</aside></a>
        </li>
    
        <li>
            <a href="/2018/03/solr-contextual-synonyms-with-payloads/">Solr Contextual Synonyms with Payloads<aside class="dates">Mar 6 2018</aside></a>
        </li>
    
</ul>



        <footer id="footer">
    
        <div id="social">
    
    <a class="symbol github" href="https://github.com/jorgelbg">
    
        <svg height="30" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M255.968 5.329C114.624 5.329 0 120.401 0 262.353c0 113.536 73.344 209.856 175.104 243.872 12.8 2.368 17.472-5.568 17.472-12.384 0-6.112-.224-22.272-.352-43.712-71.2 15.52-86.24-34.464-86.24-34.464-11.616-29.696-28.416-37.6-28.416-37.6-23.264-15.936 1.728-15.616 1.728-15.616 25.696 1.824 39.2 26.496 39.2 26.496 22.848 39.264 59.936 27.936 74.528 21.344 2.304-16.608 8.928-27.936 16.256-34.368-56.832-6.496-116.608-28.544-116.608-127.008 0-28.064 9.984-51.008 26.368-68.992-2.656-6.496-11.424-32.64 2.496-68 0 0 21.504-6.912 70.4 26.336 20.416-5.696 42.304-8.544 64.096-8.64 21.728.128 43.648 2.944 64.096 8.672 48.864-33.248 70.336-26.336 70.336-26.336 13.952 35.392 5.184 61.504 2.56 68 16.416 17.984 26.304 40.928 26.304 68.992 0 98.72-59.84 120.448-116.864 126.816 9.184 7.936 17.376 23.616 17.376 47.584 0 34.368-.32 62.08-.32 70.496 0 6.88 4.608 14.88 17.6 12.352C438.72 472.145 512 375.857 512 262.353 512 120.401 397.376 5.329 255.968 5.329z"/></svg>
    
    </a>
    
    <a class="symbol twitter" href="https://www.twitter.com/jorgelbgm">
    
        <svg height="30" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 612 612"><path d="M612 116.258a250.714 250.714 0 0 1-72.088 19.772c25.929-15.527 45.777-40.155 55.184-69.411-24.322 14.379-51.169 24.82-79.775 30.48-22.907-24.437-55.49-39.658-91.63-39.658-69.334 0-125.551 56.217-125.551 125.513 0 9.828 1.109 19.427 3.251 28.606-104.326-5.24-196.835-55.223-258.75-131.174-10.823 18.51-16.98 40.078-16.98 63.101 0 43.559 22.181 81.993 55.835 104.479a125.556 125.556 0 0 1-56.867-15.756v1.568c0 60.806 43.291 111.554 100.693 123.104-10.517 2.83-21.607 4.398-33.08 4.398-8.107 0-15.947-.803-23.634-2.333 15.985 49.907 62.336 86.199 117.253 87.194-42.947 33.654-97.099 53.655-155.916 53.655-10.134 0-20.116-.612-29.944-1.721 55.567 35.681 121.536 56.485 192.438 56.485 230.948 0 357.188-191.291 357.188-357.188l-.421-16.253c24.666-17.593 46.005-39.697 62.794-64.861z" fill="#010002"/></svg>
    
    </a>
    
    
    <a href="http://jorgelbg.github.io/index.xml" class="symbol rss">
        <svg height="28" version="1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 559 559"><path d="M53 0a497 497 0 0 1 358 148 508 508 0 0 1 148 358c0 15-5 27-15 38a51 51 0 0 1-38 15c-15 0-27-5-38-15a51 51 0 0 1-15-38 390 390 0 0 0-117-282A400 400 0 0 0 53 106 52 52 0 0 1 0 53c0-14 5-27 16-37C26 5 39 0 53 0zm0 201c42 0 82 8 119 25s69 37 96 65a312 312 0 0 1 90 215c0 15-5 27-16 38a51 51 0 0 1-37 15c-15 0-27-5-38-15a51 51 0 0 1-15-38 192 192 0 0 0-59-140 201 201 0 0 0-140-58c-14 0-27-5-37-16-11-10-16-23-16-37s5-28 16-38c10-10 23-16 37-16zm98 280a73 73 0 0 1-45 69c-10 4-19 6-30 6a73 73 0 0 1-68-46 74 74 0 0 1 39-98 74 74 0 0 1 104 69z" fill="#010002"/></svg>
    </a>
    
</div>

    
    <p class="small">
    
        © Copyright 2019 Jorge Luis Betancourt
    
    </p>
</footer>

    </section>
    

<script src="http://jorgelbg.github.io/js/highlight.js"></script>
<script>hljs.initHighlightingOnLoad();</script>




<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-115201846-1', 'auto');
	
	ga('send', 'pageview');
}
</script>


</body>
</html>
