<!doctype html><html lang=en-us><head><link rel=preload href=//jorgelbg.me/css/style.css as=style><link rel=stylesheet href=//jorgelbg.me/css/style.css media=print onload="this.media='all'"><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><meta name=viewport content="width=device-width,initial-scale=1"><meta name=author content="Jorge Luis Betancourt"><meta name=description content="Computo Ergo Sum"><meta name=generator content="Hugo 0.58.3"><title>Solr Contextual Synonyms with Payloads</title><link rel="shortcut icon" href=//jorgelbg.me/images/favicon.ico><link rel=dns-prefetch href=//www.google-analytics.com/><link href=//jorgelbg.me/index.xml rel=alternate type=application/rss+xml title="Jorge Luis Betancourt"><meta property=og:title content="Solr Contextual Synonyms with Payloads"><meta property=og:description content="A different approach for contextual synonyms with Apache Solr using the term payload"><meta property=og:type content=article><meta property=og:url content=//jorgelbg.me/2018/03/solr-contextual-synonyms-with-payloads/><meta property=article:published_time content=2018-03-06T01:00:00+01:00><meta property=article:modified_time content=2018-03-06T01:00:00+01:00><meta itemprop=name content="Solr Contextual Synonyms with Payloads"><meta itemprop=description content="A different approach for contextual synonyms with Apache Solr using the term payload"><meta itemprop=datePublished content=2018-03-06T01:00:00&#43;01:00><meta itemprop=dateModified content=2018-03-06T01:00:00&#43;01:00><meta itemprop=wordCount content=2311><meta itemprop=keywords content=solr,synonyms,><meta name=twitter:card content=summary><meta name=twitter:title content="Solr Contextual Synonyms with Payloads"><meta name=twitter:description content="A different approach for contextual synonyms with Apache Solr using the term payload"><meta name=twitter:site content=@https://twitter.com/jorgelbg></head><body><section id=wrapper><nav class=main-nav><a href=//jorgelbg.me></a></nav><article class=post><header><h1><a href=/2018/03/solr-contextual-synonyms-with-payloads/><svg width="30" xmlns="http://www.w3.org/2000/svg" version="1" viewBox="0 0 483 483"><path d="M255 209c-5 6-5 14 0 19 22 22 22 58 0 80L140 423a56 56 0 0 1-79 0l-18-17a56 56 0 0 1 0-80l115-115c6-5 6-14 1-19s-14-5-20 0L24 307a83 83 0 0 0 0 118l18 17a83 83 0 0 0 117 0l115-115c33-32 33-85 0-118-5-5-13-5-19 0z"/><path d="M459 58l-18-17a83 83 0 0 0-117 0L209 156a83 83 0 0 0 0 118c5 5 13 5 19 0s5-14 0-20a56 56 0 0 1 0-79L343 60c22-22 57-22 79 0l17 17c22 22 22 58 0 80L324 272c-5 5-5 13 0 19 3 2 7 4 10 4s7-1 9-4l115-115a83 83 0 0 0 1-118z"/></svg>Solr Contextual Synonyms with Payloads</a></h1><h2 class=headline>March 6, 2018<br><br><span class=tag><svg fill="#718096" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16"><path class="heroicon-ui" d="M2.59 13.41A1.98 1.98.0 0 1 2 12V7a5 5 0 0 1 5-5h4.99c.53.0 1.04.2 1.42.59l8 8a2 2 0 0 1 0 2.82l-8 8a2 2 0 0 1-2.82.0l-8-8zM20 12l-8-8H7a3 3 0 0 0-3 3v5l8 8 8-8zM7 8a1 1 0 1 1 0-2 1 1 0 0 1 0 2z"/></svg><a style=margin-left:10px href=//jorgelbg.me/tags/solr>solr</a></span>
<span class=tag><svg fill="#718096" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="16" height="16"><path class="heroicon-ui" d="M2.59 13.41A1.98 1.98.0 0 1 2 12V7a5 5 0 0 1 5-5h4.99c.53.0 1.04.2 1.42.59l8 8a2 2 0 0 1 0 2.82l-8 8a2 2 0 0 1-2.82.0l-8-8zM20 12l-8-8H7a3 3 0 0 0-3 3v5l8 8 8-8zM7 8a1 1 0 1 1 0-2 1 1 0 0 1 0 2z"/></svg><a style=margin-left:10px href=//jorgelbg.me/tags/synonyms>synonyms</a></span></h2></header><section id=post-body><p>Solr comes with a great set of tools to dealing with usual text processing tasks. One of this tools is the <code>SynonymFilterFactory</code> which allow to specify a list of synonyms. Last year we saw some <a href=https://lucidworks.com/2017/04/18/multi-word-synonyms-solr-adds-query-time-support/>improvements to this feature</a>, focused around multi word synonyms.
Even with the new changes introduced in Solr there are still some caveats, as explained by <a href=https://opensourceconnections.com/blog/2018/02/20/edismax-and-multiterm-synonyms-oddities/>Doug on this post</a>. To be honest this was developed some time ago, back when Solr 5 was the &ldquo;cool&rdquo; new version üòÅ.</p><p>This post describes a component to index token synonyms as a payload. Instead of a big file, you send the synonym as a payload for the desired token. This approach works great for single term synonyms, specifying the synonyms at index time. If you&rsquo;re curious about how this works, then continue reading.</p><h2 id=a-bit-of-history>A bit of history</h2><p>Some time ago I suggested a similar approach in this <a href=https://stackoverflow.com/questions/34122982/lucene-solr-store-offset-information-for-certain-keywords>question, posted on stackoverflow.com</a>. A user was asking to store positional information about the tokens. The end goal was to define something that we could call &ldquo;contextual synonyms&rdquo;.</p><blockquote><p>Contextual synonym: a single term can relate to different concepts in the same text.</p></blockquote><p>For instance, if we take a look at the following sentence: <code>Bill talked to the white house about the bill</code>. The first occurrence of <code>Bill</code> could be a reference to <code>Bill Clinton</code>. While the second appearance of <code>bill</code> relates to some law<sup>1</sup>. One business rule could be that a query with the term <code>Clinton</code> should match this document. I know, I know I&rsquo;m doing a lot of assumptions, but bear with me until the end. If we use the traditional synonym mechanism built in Solr, then we may set up a synonym like:</p><pre><code>bill =&gt; clinton
</code></pre><blockquote><p>Figuring out to which tokens apply the synonym is out of the scope of this post.</p></blockquote><p>Let&rsquo;s assume that we&rsquo;re using the <code>LowerCaseFilterFactory</code>. Solr doesn&rsquo;t know how to differentiate between the two occurrences of <code>bill</code>. We need some mechanism to tell Solr that <code>clinton</code> is also a synonym of only the <strong>first</strong> occurrence of <code>bill</code>. In short, this query: <code>&quot;clinton talked&quot;</code> should then match our document, but not this one <code>&quot;about clinton&quot;</code>.</p><p>Solr doesn&rsquo;t provide an out-of-the-box approach for deciding when to apply or not a synonym. But using some Lucene/Solr sauce we can do it. Lucene stores some positional information for each token. What we want is to have some mechanism to adding the synonym only for certain tokens. Turns out that Lucene already provides a way to attach some &ldquo;metadata&rdquo; to a token: a payload. This <em>payload</em> could be anything that we want. It&rsquo;s encoded as an array of <code>bytes</code> (<code>bytes[]</code>). Solr exposes this feature as a <code>TokenFilter</code> that uses a delimiter to split the token from the payload. We also have access to several encoders (<code>FloatEncoder</code>, <code>IntegerEncoder</code>, <code>IdentityEncoder</code>) to store <code>floats</code>, <code>integers</code>, and <code>strings</code>.</p><p>In Solr indexing payloads is very easy, in this case we&rsquo;re using the (<code>|</code>) pipe character as the delimiter.</p><div class=highlight><pre class=chroma><code class=language-xml data-lang=xml><span class=nt>&lt;filter</span> <span class=na>class=</span><span class=s>&#34;solr.DelimitedPayloadTokenFilterFactory&#34;</span> <span class=na>delimiter=</span><span class=s>&#34;|&#34;</span> <span class=na>encoder=</span><span class=s>&#34;identity&#34;</span><span class=nt>/&gt;</span></code></pre></div><p>Any token in the form of <code>A|B</code> sent to Solr will be interpreted as token <code>A</code> with payload <code>B</code>. The <code>DelimitedPayloadTokenFilterFactory</code> will remove <code>|B</code> from the token before sending it down the analysis chain. If we send the following into Solr:</p><pre><code>Bill|Clinton talked to the white house about the bill
</code></pre><p><code>Clinton</code> will be stored as the payload of the <code>Bill</code> token and the later <code>bill</code> will remain unchanged.</p><p>This doesn&rsquo;t solve our problem, but we&rsquo;re on track, so far we&rsquo;ve found a way to send custom tokens (synonyms) into Solr. The <em>payload</em> metadata is usually <a href=https://lucidworks.com/blog/2014/06/13/end-to-end-payload-example-in-solr/>used to influence the score calculation</a>. We&rsquo;re going to write our own <code>TokenFilter</code> that reads the payload and will add it to the token stream.</p><p>This should be a more straight forward synonym implementation. We don&rsquo;t need to parse any rule to find which synonym to use, and we already know <em>where</em> and <em>what</em> token to add.</p><h2 id=the-code>The code</h2><p>Now we know what we need to write, so let&rsquo;s doit.</p><p>Writing a <code>TokenFilter</code> is not that hard, but of course depends on the task at hand. We need a class that extends from <code>TokenFilter</code> and overrides the <code>incrementToken()</code> method. As described on JavaDoc:</p><blockquote><p>This method is used to advance the stream to the next token and should return <code>false</code> for the end of the stream of tokens and <code>true</code> otherwise.</p></blockquote><p>Our custom filter will access the term&rsquo;s payload using the <code>PayloadAttribute</code> class. This property will provide read/write access to the payload of the current term. The API around the token stream is an iterator, and each call to <code>incrementToken()</code> will advance to the next token.</p><p>Suppose we send the following document into solr: <code>A B|E C</code>, what we&rsquo;re trying to say is that <code>E</code> is a synonym of <code>B</code>. This means that phrase queries should continue to work as expected. Bottom line we need our method to output a token graph (Yes! Token streams in Lucene are graphs‚ÄºÔ∏è) like this:</p><div class=highlight><pre class=chroma><code class=language-json data-lang=json><span class=err>(A</span><span class=mi>0</span><span class=err>)</span> <span class=err>----&gt;</span> <span class=err>(B</span><span class=mi>1</span><span class=err>)</span> <span class=err>----&gt;</span> <span class=err>(C</span><span class=mi>2</span><span class=err>)</span>
  <span class=err>\</span>                  <span class=err>/</span>
    <span class=err>-----&gt;</span> <span class=err>(E</span><span class=mi>1</span><span class=err>)</span> <span class=err>----</span></code></pre></div><p>Actually, the previous graph is not an exact representation of a <code>TokenStream</code>. If we&rsquo;re going to get serious the graph will look more like this:</p><div class=highlight><pre class=chroma><code class=language-json data-lang=json>       <span class=err>A</span>          <span class=err>B</span>          <span class=err>C</span>
<span class=err>(</span><span class=mi>0</span><span class=err>)</span>  <span class=err>-----&gt;</span> <span class=err>(</span><span class=mi>1</span><span class=err>)</span> <span class=err>-----&gt;</span> <span class=err>(</span><span class=mi>2</span><span class=err>)</span> <span class=err>-----&gt;</span> <span class=err>(</span><span class=mi>3</span><span class=err>)</span>
               <span class=err>\</span>      <span class=err>/</span>
                <span class=err>-----</span>  
                  <span class=err>E</span></code></pre></div><p>The tokens are placed in the edges of the graph and the nodes are the states/positions of the token. But for our task at hand we can rely on the first graph for an easier representation.</p><p>So <code>B</code> and <code>E</code> should have the same position in the token graph (1). A phrase query like: <code>&quot;B C&quot;</code> will match our document, but also <code>&quot;E C&quot;</code> or <code>&quot;A E&quot;</code>. To do this we&rsquo;ll need to use the <code>PositionIncrementAttribute</code> class. The code for our <code>incrementToken()</code> method is roughly something like:</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=k>if</span> <span class=p>(</span><span class=o>!</span><span class=n>extraTokens</span><span class=p>.</span><span class=na>isEmpty</span><span class=p>())</span> <span class=p>{</span>
  <span class=n>restoreState</span><span class=p>(</span><span class=n>state</span><span class=p>);</span>

  <span class=n>posIncrAtt</span><span class=p>.</span><span class=na>setPositionIncrement</span><span class=p>(</span><span class=n>0</span><span class=p>);</span> <span class=c1>// keep the same position of the token
</span><span class=c1></span>  <span class=n>typeAtt</span><span class=p>.</span><span class=na>setType</span><span class=p>(</span><span class=n>SynonymFilter</span><span class=p>.</span><span class=na>TYPE_SYNONYM</span><span class=p>);</span>
  <span class=n>termAtt</span><span class=p>.</span><span class=na>setEmpty</span><span class=p>().</span><span class=na>append</span><span class=p>(</span><span class=n>extraTokens</span><span class=p>.</span><span class=na>remove</span><span class=p>());</span>

  <span class=k>return</span> <span class=kc>true</span><span class=p>;</span>
<span class=p>}</span>

<span class=k>if</span> <span class=p>(</span><span class=n>input</span><span class=p>.</span><span class=na>incrementToken</span><span class=p>())</span> <span class=p>{</span>
  <span class=n>BytesRef</span> <span class=nf>payload</span> <span class=o>=</span> <span class=n>payAtt</span><span class=p>.</span><span class=na>getPayload</span><span class=p>();</span>

  <span class=n>extraTokens</span><span class=p>.</span><span class=na>add</span><span class=p>(</span><span class=n>payload</span><span class=p>.</span><span class=na>utf8ToString</span><span class=p>());</span>
  <span class=n>state</span> <span class=o>=</span> <span class=n>captureState</span><span class=p>();</span>

  <span class=k>return</span> <span class=kc>true</span><span class=p>;</span>
<span class=p>}</span>

<span class=k>return</span> <span class=kc>false</span><span class=p>;</span>
<span class=p>}</span></code></pre></div><p>The <code>incrementToken()</code> method returns the metadata for the next token. Because of this, we need to save the state of the attributes to &ldquo;insert&rdquo; the synonym in the right position. Also the position increment needs to be set to 0 or the term will be in the wrong position.</p><p>Our implementation detects the token with a payload and in the next call we add the payload as a new token. In the final implementation we do a couple more of things:</p><ul><li>remove the payload (since we don&rsquo;t need it anymore)</li><li>split the payload using a delimiter character to generate several synonyms</li></ul><h2 id=testing>Testing</h2><p>How do we test that our implementation is working as intended? At this stage you may compile your project, generate a jar and add it to Solr and hope that all works well.</p><p>The best approach for testing our implementation is writing a Unit Test. Thanks to the amazing committers and community, Lucene already ships with <code>BaseTokenStreamTestCase</code>. A base class that provides several helper methods for testing.</p><p>But what do we want to test?</p><p>To &ldquo;glue&rdquo; everything in Solr, we need the <code>solr.DelimitedPayloadTokenFilterFactory</code> to index tokens and payloads. But this class is already tested in the Lucence/Solr codebase. For testing our custom filter we need tokens with payloads attached. Let&rsquo;s write a dummy <code>TokenFilter</code> that will provide us with a proper stream of tokens with payloads.</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=kd>private</span> <span class=nf>final</span> <span class=kd>class</span> <span class=nf>DummyPayloadTokenFilter</span> <span class=kd>extends</span> <span class=nf>TokenFilter</span> <span class=p>{</span>
  <span class=kd>private</span> <span class=nf>final</span> <span class=n>CharTermAttribute</span> <span class=nf>termAtt</span> <span class=o>=</span> <span class=n>addAttribute</span><span class=p>(</span><span class=n>CharTermAttribute</span><span class=p>.</span><span class=na>class</span><span class=p>);</span>
  <span class=kd>private</span> <span class=nf>final</span> <span class=n>PayloadAttribute</span> <span class=nf>payAtt</span> <span class=o>=</span> <span class=n>addAttribute</span><span class=p>(</span><span class=n>PayloadAttribute</span><span class=p>.</span><span class=na>class</span><span class=p>);</span>

  <span class=kd>private</span> <span class=nf>final</span> <span class=n>List</span><span class=o>&lt;</span><span class=n>String</span><span class=o>&gt;</span> <span class=nf>payloadTokens</span> <span class=o>=</span> <span class=n>Arrays</span><span class=p>.</span><span class=na>asList</span><span class=p>(</span><span class=s>&#34;A&#34;</span><span class=p>,</span> <span class=s>&#34;B&#34;</span><span class=p>,</span> <span class=s>&#34;C&#34;</span><span class=p>);</span>
  <span class=kd>private</span> <span class=nf>final</span> <span class=n>PayloadEncoder</span> <span class=nf>encoder</span> <span class=o>=</span> <span class=k>new</span> <span class=n>IdentityEncoder</span><span class=p>();</span>
  <span class=kd>private</span> <span class=nf>final</span> <span class=n>BytesRef</span> <span class=nf>payload</span><span class=p>;</span>

  <span class=kd>private</span> <span class=nf>DummyPayloadTokenFilter</span><span class=p>(</span><span class=n>TokenStream</span> <span class=nf>input</span><span class=p>)</span> <span class=p>{</span>
    <span class=kd>super</span><span class=p>(</span><span class=n>input</span><span class=p>);</span>
    <span class=k>this</span><span class=p>.</span><span class=na>payload</span> <span class=o>=</span> <span class=n>encoder</span><span class=p>.</span><span class=na>encode</span><span class=p>(</span><span class=s>&#34;D&#34;</span><span class=p>.</span><span class=na>toCharArray</span><span class=p>());</span>
  <span class=p>}</span>

  <span class=kd>private</span> <span class=nf>DummyPayloadTokenFilter</span><span class=p>(</span><span class=n>TokenStream</span> <span class=nf>input</span><span class=p>,</span> <span class=n>String</span> <span class=nf>payloadValue</span><span class=p>)</span> <span class=p>{</span>
    <span class=kd>super</span><span class=p>(</span><span class=n>input</span><span class=p>);</span>
    <span class=k>this</span><span class=p>.</span><span class=na>payload</span> <span class=o>=</span> <span class=n>encoder</span><span class=p>.</span><span class=na>encode</span><span class=p>(</span><span class=n>payloadValue</span><span class=p>.</span><span class=na>toCharArray</span><span class=p>());</span>
  <span class=p>}</span>

  <span class=nd>@Override</span>
  <span class=kd>public</span> <span class=nf>boolean</span> <span class=n>incrementToken</span><span class=p>()</span> <span class=kd>throws</span> <span class=nf>IOException</span> <span class=p>{</span>
    <span class=k>if</span> <span class=p>(</span><span class=n>input</span><span class=p>.</span><span class=na>incrementToken</span><span class=p>())</span> <span class=p>{</span>
      <span class=k>if</span> <span class=p>(</span><span class=n>payloadTokens</span><span class=p>.</span><span class=na>contains</span><span class=p>(</span><span class=n>termAtt</span><span class=p>.</span><span class=na>toString</span><span class=p>()))</span> <span class=n>payAtt</span><span class=p>.</span><span class=na>setPayload</span><span class=p>(</span><span class=n>payload</span><span class=p>);</span>
      <span class=k>return</span> <span class=kc>true</span><span class=p>;</span>
    <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
      <span class=k>return</span> <span class=kc>false</span><span class=p>;</span>
    <span class=p>}</span>
  <span class=p>}</span>
<span class=p>}</span></code></pre></div><p>With this dummy <code>TokenFilter</code> we can wrap a mock of a <code>TokenStream</code> and feed it into our <code>PayloadSynonymTokenFilter</code> and test our custom logic.</p><p>Now to the next item, how do we test a <code>TokenFilter</code>? We need to start with a string (<code>A B C</code>), which needs to converted into a <code>TokenStream</code>. For this we can use the handy helper method <code>whitespaceMockTokenizer()</code>. This methods will tokenize the string at any occurrence of a whitespace character. Once we have an actual <code>TokenStream</code> to feed to our filter we can start writting assertions.</p><p>We need to call <code>incrementToken()</code> and at each step check if the current term is correct and if any other term attribute (such as our beloved payload) has also the expected value.</p><p>This assertions are not hard to write. Peeking around the Lucene test suite I came across this handy method than resembled a lot to what I was writing. I decided to use it instead (no harm no fall).</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=kt>void</span> <span class=nf>assertTermEquals</span><span class=p>(</span><span class=n>String</span> <span class=nf>expected</span><span class=p>,</span> <span class=n>TokenStream</span> <span class=nf>stream</span><span class=p>,</span> <span class=n>CharTermAttribute</span> <span class=nf>termAtt</span><span class=p>,</span> <span class=n>PayloadAttribute</span> <span class=nf>payAtt</span><span class=p>,</span>
    <span class=kt>byte</span><span class=p>[]</span> <span class=nf>expectPay</span><span class=p>)</span> <span class=kd>throws</span> <span class=nf>Exception</span> <span class=p>{</span>
  <span class=n>assertTrue</span><span class=p>(</span><span class=n>stream</span><span class=p>.</span><span class=na>incrementToken</span><span class=p>());</span>
  <span class=n>assertEquals</span><span class=p>(</span><span class=n>expected</span><span class=p>,</span> <span class=n>termAtt</span><span class=p>.</span><span class=na>toString</span><span class=p>());</span>
  <span class=n>BytesRef</span> <span class=nf>payload</span> <span class=o>=</span> <span class=n>payAtt</span><span class=p>.</span><span class=na>getPayload</span><span class=p>();</span>

  <span class=k>if</span> <span class=p>(</span><span class=n>payload</span> <span class=o>!=</span> <span class=kc>null</span><span class=p>)</span> <span class=p>{</span>
    <span class=n>assertTrue</span><span class=p>(</span><span class=n>payload</span><span class=p>.</span><span class=na>length</span> <span class=o>+</span> <span class=s>&#34; does not equal: &#34;</span> <span class=o>+</span> <span class=n>expectPay</span><span class=p>.</span><span class=na>length</span><span class=p>,</span> <span class=n>payload</span><span class=p>.</span><span class=na>length</span> <span class=o>==</span> <span class=n>expectPay</span><span class=p>.</span><span class=na>length</span><span class=p>);</span>
    <span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=nf>i</span> <span class=o>=</span> <span class=n>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>expectPay</span><span class=p>.</span><span class=na>length</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
      <span class=n>assertTrue</span><span class=p>(</span><span class=n>expectPay</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>+</span> <span class=s>&#34; does not equal: &#34;</span> <span class=o>+</span> <span class=n>payload</span><span class=p>.</span><span class=na>bytes</span><span class=p>[</span><span class=n>i</span> <span class=o>+</span> <span class=n>payload</span><span class=p>.</span><span class=na>offset</span><span class=p>],</span>
          <span class=n>expectPay</span><span class=p>[</span><span class=n>i</span><span class=p>]</span> <span class=o>==</span> <span class=n>payload</span><span class=p>.</span><span class=na>bytes</span><span class=p>[</span><span class=n>i</span> <span class=o>+</span> <span class=n>payload</span><span class=p>.</span><span class=na>offset</span><span class=p>]);</span>
    <span class=p>}</span>
  <span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
    <span class=n>assertTrue</span><span class=p>(</span><span class=s>&#34;expectPay is not null and it should be&#34;</span><span class=p>,</span> <span class=n>expectPay</span> <span class=o>==</span> <span class=kc>null</span><span class=p>);</span>
  <span class=p>}</span>
<span class=p>}</span></code></pre></div><p>Using this method our test code is a series of calls to <code>assertTermEquals</code> passing the right arguments.</p><p>Let&rsquo;s go back to our initial test string. Assuming that only the <code>A</code> token carries a payload, our expected <code>TokenStream</code> should look like <code>A D B C</code>. <code>D</code> should be a synonym of <code>A</code>: both <code>A</code> and <code>D</code> should have the same position in the stream. The test would look something like:</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=nd>@Test</span>
<span class=kd>public</span> <span class=nf>void</span> <span class=n>testSingleSynonym</span><span class=p>()</span> <span class=kd>throws</span> <span class=nf>Exception</span> <span class=p>{</span>
  <span class=n>String</span> <span class=nf>test</span> <span class=o>=</span> <span class=s>&#34;A B C&#34;</span><span class=p>;</span>

  <span class=n>PayloadSynonymTokenFilter</span> <span class=nf>filter</span> <span class=o>=</span> <span class=k>new</span> <span class=n>PayloadSynonymTokenFilter</span><span class=p>(</span>
    <span class=k>new</span> <span class=n>DummyPayloadTokenFilter</span><span class=p>(</span><span class=n>whitespaceMockTokenizer</span><span class=p>(</span><span class=n>test</span><span class=p>)),</span>
    <span class=kc>false</span><span class=p>,</span> <span class=kc>false</span><span class=p>,</span> <span class=s>&#34;_&#34;</span>
  <span class=p>);</span>

  <span class=n>CharTermAttribute</span> <span class=nf>termAtt</span> <span class=o>=</span> <span class=n>filter</span><span class=p>.</span><span class=na>getAttribute</span><span class=p>(</span><span class=n>CharTermAttribute</span><span class=p>.</span><span class=na>class</span><span class=p>);</span>
  <span class=n>PayloadAttribute</span> <span class=nf>payAtt</span> <span class=o>=</span> <span class=n>filter</span><span class=p>.</span><span class=na>getAttribute</span><span class=p>(</span><span class=n>PayloadAttribute</span><span class=p>.</span><span class=na>class</span><span class=p>);</span>

  <span class=n>filter</span><span class=p>.</span><span class=na>reset</span><span class=p>();</span>

  <span class=n>assertTermEquals</span><span class=p>(</span><span class=s>&#34;A&#34;</span><span class=p>,</span> <span class=n>filter</span><span class=p>,</span> <span class=n>termAtt</span><span class=p>,</span> <span class=n>payAtt</span><span class=p>,</span>
    <span class=s>&#34;D&#34;</span><span class=p>.</span><span class=na>getBytes</span><span class=p>(</span><span class=n>StandardCharsets</span><span class=p>.</span><span class=na>UTF_8</span><span class=p>)</span>
  <span class=p>);</span>
  <span class=n>assertTermEquals</span><span class=p>(</span><span class=s>&#34;D&#34;</span><span class=p>,</span> <span class=n>filter</span><span class=p>,</span> <span class=n>termAtt</span><span class=p>,</span> <span class=n>payAtt</span><span class=p>,</span>
    <span class=s>&#34;D&#34;</span><span class=p>.</span><span class=na>getBytes</span><span class=p>(</span><span class=n>StandardCharsets</span><span class=p>.</span><span class=na>UTF_8</span><span class=p>)</span>
  <span class=p>);</span>
  <span class=n>assertTermEquals</span><span class=p>(</span><span class=s>&#34;B&#34;</span><span class=p>,</span> <span class=n>filter</span><span class=p>,</span> <span class=n>termAtt</span><span class=p>,</span> <span class=n>payAtt</span><span class=p>,</span> <span class=kc>null</span><span class=p>);</span>
  <span class=n>assertTermEquals</span><span class=p>(</span><span class=s>&#34;C&#34;</span><span class=p>,</span> <span class=n>filter</span><span class=p>,</span> <span class=n>termAtt</span><span class=p>,</span> <span class=n>payAtt</span><span class=p>,</span> <span class=kc>null</span><span class=p>);</span>
  <span class=n>assertFalse</span><span class=p>(</span><span class=n>filter</span><span class=p>.</span><span class=na>incrementToken</span><span class=p>());</span>

  <span class=n>filter</span><span class=p>.</span><span class=na>end</span><span class=p>();</span>
  <span class=n>filter</span><span class=p>.</span><span class=na>close</span><span class=p>();</span>
<span class=p>}</span></code></pre></div><p>For the <code>A</code> and <code>D</code> tokens we&rsquo;re also checking that the payload is still there (since we haven&rsquo;t removed it yet), but for <code>B</code> and <code>C</code> there should be no payload at all, so we pass a <code>null</code> parameter to validate this assumption.</p><p>Its important to check that the filter returns <code>false</code> when it reaches the end of the <code>TokenStream</code>.</p><p>There is still something missing in our test. Let&rsquo;s go back to the couple of figures at the beginning of the post, where we represent the <code>TokenStream</code> as a graph. In those graphs we can see that the token and the synonym should have the same <strong>positional information</strong>. In other words, both terms should be at the same position within the token stream. Or, said in the &ldquo;Lucene jargon&rdquo; the position increment of the synonym should be <code>0</code>. To check this in our test we need to use the <code>PositionIncrementAttribute</code> class:</p><div class=highlight><pre class=chroma><code class=language-java data-lang=java><span class=n>PositionIncrementAttribute</span> <span class=nf>posIncAtt</span> <span class=o>=</span>
    <span class=n>filter</span><span class=p>.</span><span class=na>getAttribute</span><span class=p>(</span><span class=n>PositionIncrementAttribute</span><span class=p>.</span><span class=na>class</span><span class=p>);</span>

<span class=n>assertEquals</span><span class=p>(</span><span class=n>0</span><span class=p>,</span> <span class=n>posIncAtt</span><span class=p>.</span><span class=na>getPositionIncrement</span><span class=p>());</span></code></pre></div><p>The default position increment for the rest of the <code>TokenStream</code> should be 1, which we could also test.</p><p>Lucene use &ldquo;attributes&rdquo; to store information about a single token. Instead of storing the actual position of a term, Lucene stores the increment of each token. This <code>increment</code> is then used to figure out the actual position of the token in the stream. We can see this information in the analysis page of the Solr Admin UI. This is the internal mechanism that Lucene uses for phrase search and span queries, etc.</p><h2 id=using-in-solr>Using in Solr</h2><p>The entire code of this example is available in this <a href=https://github.com/jorgelbg/solr-payload-synonyms>Github repo</a>. You can build it using maven and then enable it in your Solr/Fusion installation as a normal filter:</p><div class=highlight><pre class=chroma><code class=language-xml data-lang=xml><span class=nt>&lt;fieldtype</span> <span class=na>name=</span><span class=s>&#34;payloads&#34;</span> <span class=na>stored=</span><span class=s>&#34;false&#34;</span> <span class=na>indexed=</span><span class=s>&#34;true&#34;</span> <span class=na>class=</span><span class=s>&#34;solr.TextField&#34;</span> <span class=nt>&gt;</span>
 <span class=nt>&lt;analyzer&gt;</span>
   <span class=nt>&lt;tokenizer</span> <span class=na>class=</span><span class=s>&#34;solr.WhitespaceTokenizerFactory&#34;</span><span class=nt>/&gt;</span>
   <span class=nt>&lt;filter</span> <span class=na>class=</span><span class=s>&#34;solr.DelimitedPayloadTokenFilterFactory&#34;</span> <span class=na>delimiter=</span><span class=s>&#34;|&#34;</span> <span class=na>encoder=</span><span class=s>&#34;identity&#34;</span><span class=nt>/&gt;</span>
   <span class=nt>&lt;filter</span> <span class=na>class=</span><span class=s>&#34;solr.custom.PayloadSynonymTokenFilterFactory&#34;</span><span class=nt>/&gt;</span>
 <span class=nt>&lt;/analyzer&gt;</span>
<span class=nt>&lt;/fieldtype&gt;</span></code></pre></div><p>Once our <code>fieldtype</code> is defined we can use the very helpful Analysis page of the Solr Admin UI to check if things are working as expected. If we use the test string: <code>Bill|Clinton talked about the bill</code> in the Field value (index) input and select our payload <code>fieldtype</code> we can see an output similar to what is shown in the figure.</p><p><img src=/images/solr-synonyms/analysis-ui.png alt="Solr Admin UI" title="Solr Admin UI"></p><p>A quick inspection, reveals that the tokens <code>Bill</code> and <code>Clinton</code> have the same positional information. Also the <code>Clinton</code> token has a defined type of <code>SYNONYM</code>.</p><h2 id=advantages-to-this-approach>Advantages to this approach?</h2><p>One question you may been doing yourself is what advantages provides this approach?</p><p>This approach <em>decentralizes</em> the synonyms management. Usually your synonyms live in a big text file on the filesystem of your Solr server. Adding new synonyms means editing that file and adding a new rule.</p><p>In recent Solr versions, the <code>ManagedSynonymFilterFactory</code> class provides an HTTP endpoint to do this. But it is not a good idea to give everyone on your team access to this endpoints. I used this approach in a cloud-like environment for Solr. We provided Solr as a service to different teams with different needs. Along with the service we provided our own utility library for interacting with Solr. In this library we did the heavy lifting and exposed a clean and easy API for the developers.</p><p>In this environment this approach gave control over the synonyms to each developer. They could customize their synonyms without knowing the inner workings of Solr.</p><p>And of course this solves part of our initial statement: tailoring a synonym to a specific term/token.</p><p>To wrap things up this has been a fun exercise and an atypical use of Lucene/Solr payloads. If it is useful to you then use it if not I hope you&rsquo;ve enjoyed the reading, I&rsquo;ve enjoyed the journey!</p></section></article><footer id=post-meta class=clearfix><svg class="avatar" width="50" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path fill="#cbd5e0" d="M20.3 12.04l1.01 3a1 1 0 0 1-1.26 1.27l-3.01-1a7 7 0 1 1 3.27-3.27zM11 10a1 1 0 1 0 0-2 1 1 0 0 0 0 2zm3 0a1 1 0 1 0 0-2 1 1 0 0 0 0 2zm3 0a1 1 0 1 0 0-2 1 1 0 0 0 0 2z"/><path fill="#4a5568" d="M15.88 17.8a7 7 0 0 1-8.92 2.5l-3 1.01a1 1 0 0 1-1.27-1.26l1-3.01A6.97 6.97.0 0 1 5 9.1a9 9 0 0 0 10.88 8.7z"/></svg><a href=https://twitter.com/jorgelbg><div><span class=dark>Want to leave a comment?</span>
<span>Drop me a message on Twitter @jorgelbg</span></div></a><section id=sharing><a class=twitter target=_blank href="https://twitter.com/intent/tweet?text=%2f%2fjorgelbg.me%2f2018%2f03%2fsolr-contextual-synonyms-with-payloads%2f - Solr%20Contextual%20Synonyms%20with%20Payloads by @jorgelbg"><span class=icon-twitter>tweet</span></a></section></footer><ul id=post-list class="archive readmore"><h3>Read more</h3><li><a href=/2019/05/how-to-rename-index-patterns-in-kibana/>How to rename index patterns in Kibana<aside class=dates>May 21 2019</aside></a></li><li><a href=/2019/03/useful-alerts-with-elastic-watcher-machine-learning/>Useful alerts with Elastic Watcher &amp; Machine Learning<aside class=dates>Mar 15 2019</aside></a></li><li><a href=/2019/02/display-the-applications-version-in-your-grafana-dashboards/>Display the application&#39;s version in your Grafana dashboards<aside class=dates>Feb 17 2019</aside></a></li></ul><footer id=footer><p class=small>¬© Copyright 2019 Jorge Luis Betancourt</p><p class="small cc">Icons made by
<a href=https://www.freepik.com/ title=Freepik>Freepik</a> from
<a href=https://www.flaticon.com/ title=Flaticon>www.flaticon.com</a> is
licensed by
<a href=https://creativecommons.org/licenses/by/3.0/ title="Creative Commons BY 3.0" target=_blank>CC 3.0 BY</a></p></footer></section><script type=application/javascript>var doNotTrack=false;if(!doNotTrack){(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');ga('create','UA-115201846-1','auto');ga('send','pageview');}</script></body></html>